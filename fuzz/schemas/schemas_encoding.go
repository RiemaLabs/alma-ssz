// Code generated by fastssz. DO NOT EDIT.
// Hash: 23374924e4b7a84fa094a1a615a45f6ca2b422f74e43063e3db0d687d6162c3b
// Version: 2.0.0
package schemas

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the BitvectorStruct object
func (b *BitvectorStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitvectorStruct object to a target array
func (b *BitvectorStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'ValidationBits'
	dst = append(dst, b.ValidationBits[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitvectorStruct object
func (b *BitvectorStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitvectorStruct object and returns the remaining bufferº
func (b *BitvectorStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'ValidationBits'
	buf = ssz.UnmarshalFixedBytes(b.ValidationBits[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BitvectorStruct object
func (b *BitvectorStruct) fixedSize() int {
	return int(1)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitvectorStruct object
func (b *BitvectorStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BitvectorStruct object
func (b *BitvectorStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitvectorStruct object with a hasher
func (b *BitvectorStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidationBits'
	hh.PutBytes(b.ValidationBits[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitvectorStruct object
func (b *BitvectorStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BooleanStruct object
func (b *BooleanStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BooleanStruct object to a target array
func (b *BooleanStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Val'
	dst = ssz.MarshalValue(dst, b.Val)

	return
}

// UnmarshalSSZ ssz unmarshals the BooleanStruct object
func (b *BooleanStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BooleanStruct object and returns the remaining bufferº
func (b *BooleanStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Val'
	if err = ssz.IsValidBool(buf); err != nil {
		return
	}
	b.Val, buf = ssz.UnmarshallValue[bool](buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BooleanStruct object
func (b *BooleanStruct) fixedSize() int {
	return int(1)
}

// SizeSSZ returns the ssz encoded size in bytes for the BooleanStruct object
func (b *BooleanStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BooleanStruct object
func (b *BooleanStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BooleanStruct object with a hasher
func (b *BooleanStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Val'
	hh.PutBool(b.Val)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BooleanStruct object
func (b *BooleanStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BitlistStruct object
func (b *BitlistStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitlistStruct object to a target array
func (b *BitlistStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Offset (0) 'Bits'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Bits'
	if size := ssz.BitlistLen(b.Bits); size > 2048 {
		err = ssz.ErrBytesLengthFn("BitlistStruct.Bits", size, 2048)
		return
	}
	dst = append(dst, b.Bits...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitlistStruct object
func (b *BitlistStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitlistStruct object and returns the remaining bufferº
func (b *BitlistStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o0 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'Bits'
	if o0, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (0) 'Bits'
	if b.Bits, err = ssz.UnmarshalBitList(b.Bits, tail[o0:], 2048); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BitlistStruct object
func (b *BitlistStruct) fixedSize() int {
	return int(4)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitlistStruct object
func (b *BitlistStruct) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (0) 'Bits'
	size += len(b.Bits)

	return
}

// HashTreeRoot ssz hashes the BitlistStruct object
func (b *BitlistStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitlistStruct object with a hasher
func (b *BitlistStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Bits'
	if len(b.Bits) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.Bits, 2048)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitlistStruct object
func (b *BitlistStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the GapStruct object
func (g *GapStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GapStruct object to a target array
func (g *GapStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := g.fixedSize()

	// Offset (0) 'Data'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Data'
	if size := uint64(len(g.Data)); size > 1024 {
		err = ssz.ErrBytesLengthFn("GapStruct.Data", size, 1024)
		return
	}
	dst = append(dst, g.Data...)

	return
}

// UnmarshalSSZ ssz unmarshals the GapStruct object
func (g *GapStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(g, buf)
}

// UnmarshalSSZTail unmarshals the GapStruct object and returns the remaining bufferº
func (g *GapStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := g.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o0 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'Data'
	if o0, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (0) 'Data'
	if g.Data, err = ssz.UnmarshalDynamicBytes(g.Data, tail[o0:], 1024); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the GapStruct object
func (g *GapStruct) fixedSize() int {
	return int(4)
}

// SizeSSZ returns the ssz encoded size in bytes for the GapStruct object
func (g *GapStruct) SizeSSZ() (size int) {
	size = g.fixedSize()

	// Field (0) 'Data'
	size += len(g.Data)

	return
}

// HashTreeRoot ssz hashes the GapStruct object
func (g *GapStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GapStruct object with a hasher
func (g *GapStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Data'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.Data))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.Data)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GapStruct object
func (g *GapStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}
