// Code generated by fastssz. DO NOT EDIT.
// Hash: b90fb372112561de86ac9abef1ba8aee40bac076a96765343003b83da7b2390a
// Version: 2.0.0
package benchschemas

import "github.com/ferranbt/fastssz/tracer"

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Fork object
func (f *Fork) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the Fork object to a target array
func (f *Fork) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'PreviousVersion'
	dst = append(dst, f.PreviousVersion[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'CurrentVersion'
	dst = append(dst, f.CurrentVersion[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (2) 'Epoch'
	dst = ssz.MarshalValue(dst, f.Epoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the Fork object
func (f *Fork) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(f, buf)
}

// UnmarshalSSZTail unmarshals the Fork object and returns the remaining bufferº
func (f *Fork) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := f.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'PreviousVersion'
	buf = ssz.UnmarshalFixedBytes(f.PreviousVersion[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (1) 'CurrentVersion'
	buf = ssz.UnmarshalFixedBytes(f.CurrentVersion[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (2) 'Epoch'
	f.Epoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	return buf, nil
}

// fixedSize returns the fixed size of the Fork object
func (f *Fork) fixedSize() int {
	return int(16)
}

// SizeSSZ returns the ssz encoded size in bytes for the Fork object
func (f *Fork) SizeSSZ() (size int) {
	size = f.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the Fork object
func (f *Fork) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the Fork object with a hasher
func (f *Fork) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'PreviousVersion'
	hh.PutBytes(f.PreviousVersion[:])

	// Field (1) 'CurrentVersion'
	hh.PutBytes(f.CurrentVersion[:])

	// Field (2) 'Epoch'
	hh.PutUint64(f.Epoch)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Fork object
func (f *Fork) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(f)
}

// MarshalSSZ ssz marshals the BeaconBlockHeader object
func (b *BeaconBlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconBlockHeader object to a target array
func (b *BeaconBlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(b.Slot))

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalValue(dst, uint64(b.ProposerIndex))

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (3) 'StateRoot'
	dst = append(dst, b.StateRoot[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (4) 'BodyRoot'
	dst = append(dst, b.BodyRoot[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconBlockHeader object
func (b *BeaconBlockHeader) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BeaconBlockHeader object and returns the remaining bufferº
func (b *BeaconBlockHeader) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := b.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(10826477961641141902, tracer.ToScalar(buf))
		tracer.Record(3317299527078974664, tracer.ToScalar(val))
		b.Slot = Slot(val)
	}

	// Field (1) 'ProposerIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(9954389365284774257, tracer.ToScalar(buf))
		tracer.Record(17486380467104521923, tracer.ToScalar(val))
		b.ProposerIndex = ValidatorIndex(val)
	}

	// Field (2) 'ParentRoot'
	buf = ssz.UnmarshalFixedBytes(b.ParentRoot[:], buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (3) 'StateRoot'
	buf = ssz.UnmarshalFixedBytes(b.StateRoot[:], buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (4) 'BodyRoot'
	buf = ssz.UnmarshalFixedBytes(b.BodyRoot[:], buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	return buf, nil
}

// fixedSize returns the fixed size of the BeaconBlockHeader object
func (b *BeaconBlockHeader) fixedSize() int {
	return int(112)
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconBlockHeader object
func (b *BeaconBlockHeader) SizeSSZ() (size int) {
	size = b.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the BeaconBlockHeader object
func (b *BeaconBlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconBlockHeader object with a hasher
func (b *BeaconBlockHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'StateRoot'
	hh.PutBytes(b.StateRoot[:])

	// Field (4) 'BodyRoot'
	hh.PutBytes(b.BodyRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconBlockHeader object
func (b *BeaconBlockHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the Eth1Data object
func (e *Eth1Data) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(e)
}

// MarshalSSZTo ssz marshals the Eth1Data object to a target array
func (e *Eth1Data) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'DepositRoot'
	dst = append(dst, e.DepositRoot[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'DepositCount'
	dst = ssz.MarshalValue(dst, e.DepositCount)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (2) 'BlockHash'
	dst = append(dst, e.BlockHash[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the Eth1Data object
func (e *Eth1Data) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(e, buf)
}

// UnmarshalSSZTail unmarshals the Eth1Data object and returns the remaining bufferº
func (e *Eth1Data) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := e.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'DepositRoot'
	buf = ssz.UnmarshalFixedBytes(e.DepositRoot[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (1) 'DepositCount'
	e.DepositCount, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (2) 'BlockHash'
	buf = ssz.UnmarshalFixedBytes(e.BlockHash[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	return buf, nil
}

// fixedSize returns the fixed size of the Eth1Data object
func (e *Eth1Data) fixedSize() int {
	return int(72)
}

// SizeSSZ returns the ssz encoded size in bytes for the Eth1Data object
func (e *Eth1Data) SizeSSZ() (size int) {
	size = e.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the Eth1Data object
func (e *Eth1Data) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(e)
}

// HashTreeRootWith ssz hashes the Eth1Data object with a hasher
func (e *Eth1Data) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'DepositRoot'
	hh.PutBytes(e.DepositRoot[:])

	// Field (1) 'DepositCount'
	hh.PutUint64(e.DepositCount)

	// Field (2) 'BlockHash'
	hh.PutBytes(e.BlockHash[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Eth1Data object
func (e *Eth1Data) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(e)
}

// MarshalSSZ ssz marshals the Checkpoint object
func (c *Checkpoint) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Checkpoint object to a target array
func (c *Checkpoint) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Epoch'
	dst = ssz.MarshalValue(dst, c.Epoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'Root'
	dst = append(dst, c.Root[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the Checkpoint object
func (c *Checkpoint) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(c, buf)
}

// UnmarshalSSZTail unmarshals the Checkpoint object and returns the remaining bufferº
func (c *Checkpoint) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := c.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Epoch'
	c.Epoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (1) 'Root'
	buf = ssz.UnmarshalFixedBytes(c.Root[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	return buf, nil
}

// fixedSize returns the fixed size of the Checkpoint object
func (c *Checkpoint) fixedSize() int {
	return int(40)
}

// SizeSSZ returns the ssz encoded size in bytes for the Checkpoint object
func (c *Checkpoint) SizeSSZ() (size int) {
	size = c.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the Checkpoint object
func (c *Checkpoint) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Checkpoint object with a hasher
func (c *Checkpoint) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Epoch'
	hh.PutUint64(c.Epoch)

	// Field (1) 'Root'
	hh.PutBytes(c.Root[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Checkpoint object
func (c *Checkpoint) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the Validator object
func (v *Validator) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the Validator object to a target array
func (v *Validator) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Pubkey'
	dst = append(dst, v.Pubkey[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'WithdrawalCredentials'
	dst = append(dst, v.WithdrawalCredentials[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (2) 'EffectiveBalance'
	dst = ssz.MarshalValue(dst, uint64(v.EffectiveBalance))

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (3) 'Slashed'
	dst = ssz.MarshalValue(dst, v.Slashed)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (4) 'ActivationEligibilityEpoch'
	dst = ssz.MarshalValue(dst, v.ActivationEligibilityEpoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (5) 'ActivationEpoch'
	dst = ssz.MarshalValue(dst, v.ActivationEpoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (6) 'ExitEpoch'
	dst = ssz.MarshalValue(dst, v.ExitEpoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (7) 'WithdrawableEpoch'
	dst = ssz.MarshalValue(dst, v.WithdrawableEpoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the Validator object
func (v *Validator) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(v, buf)
}

// UnmarshalSSZTail unmarshals the Validator object and returns the remaining bufferº
func (v *Validator) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := v.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Pubkey'
	buf = ssz.UnmarshalFixedBytes(v.Pubkey[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (1) 'WithdrawalCredentials'
	buf = ssz.UnmarshalFixedBytes(v.WithdrawalCredentials[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (2) 'EffectiveBalance'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(10826477961641141902, tracer.ToScalar(buf))
		tracer.Record(3317299527078974664, tracer.ToScalar(val))
		v.EffectiveBalance = Gwei(val)
	}

	// Field (3) 'Slashed'
	if err = ssz.IsValidBool(buf); err != nil {
		return
	}
	v.Slashed, buf = ssz.UnmarshallValue[bool](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (4) 'ActivationEligibilityEpoch'
	v.ActivationEligibilityEpoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (5) 'ActivationEpoch'
	v.ActivationEpoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (6) 'ExitEpoch'
	v.ExitEpoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (7) 'WithdrawableEpoch'
	v.WithdrawableEpoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	return buf, nil
}

// fixedSize returns the fixed size of the Validator object
func (v *Validator) fixedSize() int {
	return int(121)
}

// SizeSSZ returns the ssz encoded size in bytes for the Validator object
func (v *Validator) SizeSSZ() (size int) {
	size = v.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the Validator object
func (v *Validator) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the Validator object with a hasher
func (v *Validator) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Pubkey'
	hh.PutBytes(v.Pubkey[:])

	// Field (1) 'WithdrawalCredentials'
	hh.PutBytes(v.WithdrawalCredentials[:])

	// Field (2) 'EffectiveBalance'
	hh.PutUint64(uint64(v.EffectiveBalance))

	// Field (3) 'Slashed'
	hh.PutBool(v.Slashed)

	// Field (4) 'ActivationEligibilityEpoch'
	hh.PutUint64(v.ActivationEligibilityEpoch)

	// Field (5) 'ActivationEpoch'
	hh.PutUint64(v.ActivationEpoch)

	// Field (6) 'ExitEpoch'
	hh.PutUint64(v.ExitEpoch)

	// Field (7) 'WithdrawableEpoch'
	hh.PutUint64(v.WithdrawableEpoch)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Validator object
func (v *Validator) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the AttestationData object
func (a *AttestationData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttestationData object to a target array
func (a *AttestationData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(a.Slot))

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'Index'
	dst = ssz.MarshalValue(dst, a.Index)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (2) 'BeaconBlockRoot'
	dst = append(dst, a.BeaconBlockRoot[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (3) 'Source'
	if dst, err = a.Source.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'Target'
	if dst, err = a.Target.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AttestationData object
func (a *AttestationData) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(a, buf)
}

// UnmarshalSSZTail unmarshals the AttestationData object and returns the remaining bufferº
func (a *AttestationData) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := a.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(10826477961641141902, tracer.ToScalar(buf))
		tracer.Record(3317299527078974664, tracer.ToScalar(val))
		a.Slot = Slot(val)
	}

	// Field (1) 'Index'
	a.Index, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	// Field (2) 'BeaconBlockRoot'
	buf = ssz.UnmarshalFixedBytes(a.BeaconBlockRoot[:], buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	// Field (3) 'Source'
	if buf, err = a.Source.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (4) 'Target'
	if buf, err = a.Target.UnmarshalSSZTail(buf); err != nil {
		return
	}

	return buf, nil
}

// fixedSize returns the fixed size of the AttestationData object
func (a *AttestationData) fixedSize() int {
	return int(128)
}

// SizeSSZ returns the ssz encoded size in bytes for the AttestationData object
func (a *AttestationData) SizeSSZ() (size int) {
	size = a.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the AttestationData object
func (a *AttestationData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttestationData object with a hasher
func (a *AttestationData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Slot'
	hh.PutUint64(uint64(a.Slot))

	// Field (1) 'Index'
	hh.PutUint64(a.Index)

	// Field (2) 'BeaconBlockRoot'
	hh.PutBytes(a.BeaconBlockRoot[:])

	// Field (3) 'Source'
	if err = a.Source.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'Target'
	if err = a.Target.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AttestationData object
func (a *AttestationData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the PendingAttestation object
func (p *PendingAttestation) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PendingAttestation object to a target array
func (p *PendingAttestation) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	tracer.Record(10095149564870410566, tracer.ToScalar(dst))
	offset := p.fixedSize()

	tracer.Record(642677820169046180, tracer.ToScalar(offset))

	// Offset (0) 'AggregationBits'
	dst = ssz.WriteOffset(dst, offset)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'Data'
	if dst, err = p.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'InclusionDelay'
	dst = ssz.MarshalValue(dst, uint64(p.InclusionDelay))

	tracer.Record(1938884375001766421, tracer.ToScalar(dst))

	// Field (3) 'ProposerIndex'
	dst = ssz.MarshalValue(dst, uint64(p.ProposerIndex))

	tracer.Record(1938884375001766421, tracer.ToScalar(dst))

	// Field (0) 'AggregationBits'
	if size := ssz.BitlistLen(p.AggregationBits); size > 2048 {
		err = ssz.ErrBytesLengthFn("PendingAttestation.AggregationBits", size, 2048)
		tracer.Record(14019338521758100300, tracer.ToScalar(err))
		return
	}
	dst = append(dst, p.AggregationBits...)

	tracer.Record(14547142586060853660, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the PendingAttestation object
func (p *PendingAttestation) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(p, buf)
}

// UnmarshalSSZTail unmarshals the PendingAttestation object and returns the remaining bufferº
func (p *PendingAttestation) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := p.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	tracer.Record(1871508765119975144, tracer.ToScalar(tail))
	var o0 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	tracer.Record(10306528967774195020, tracer.ToScalar(marker))

	// Offset (0) 'AggregationBits'
	if o0, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'Data'
	if buf, err = p.Data.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (2) 'InclusionDelay'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(16106447224004489456, tracer.ToScalar(buf))
		tracer.Record(3611726826681600054, tracer.ToScalar(val))
		p.InclusionDelay = Slot(val)
	}

	// Field (3) 'ProposerIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(2998975620494084155, tracer.ToScalar(buf))
		tracer.Record(13905864885220436833, tracer.ToScalar(val))
		p.ProposerIndex = ValidatorIndex(val)
	}

	// Field (0) 'AggregationBits'
	if p.AggregationBits, err = ssz.UnmarshalBitList(p.AggregationBits, tail[o0:], 2048); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the PendingAttestation object
func (p *PendingAttestation) fixedSize() int {
	return int(148)
}

// SizeSSZ returns the ssz encoded size in bytes for the PendingAttestation object
func (p *PendingAttestation) SizeSSZ() (size int) {
	size = p.fixedSize()

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (0) 'AggregationBits'
	size += len(p.AggregationBits)

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	return
}

// HashTreeRoot ssz hashes the PendingAttestation object
func (p *PendingAttestation) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PendingAttestation object with a hasher
func (p *PendingAttestation) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'AggregationBits'
	if len(p.AggregationBits) == 0 {
		err = ssz.ErrEmptyBitlist
		tracer.Record(10327639356949190406, tracer.ToScalar(err))
		return
	}
	hh.PutBitlist(p.AggregationBits, 2048)

	// Field (1) 'Data'
	if err = p.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'InclusionDelay'
	hh.PutUint64(uint64(p.InclusionDelay))

	// Field (3) 'ProposerIndex'
	hh.PutUint64(uint64(p.ProposerIndex))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the PendingAttestation object
func (p *PendingAttestation) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the BeaconStateBench object
func (b *BeaconStateBench) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconStateBench object to a target array
func (b *BeaconStateBench) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	tracer.Record(10095149564870410566, tracer.ToScalar(dst))
	offset := b.fixedSize()

	tracer.Record(642677820169046180, tracer.ToScalar(offset))

	// Field (0) 'GenesisTime'
	dst = ssz.MarshalValue(dst, b.GenesisTime)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'GenesisValidatorsRoot'
	dst = append(dst, b.GenesisValidatorsRoot[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (2) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(b.Slot))

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (3) 'Fork'
	if dst, err = b.Fork.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'LatestBlockHeader'
	if dst, err = b.LatestBlockHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (5) 'BlockRoots'
	if size := uint64(len(b.BlockRoots)); size != 64 {
		err = ssz.ErrVectorLengthFn("BeaconStateBench.BlockRoots", size, 64)
		tracer.Record(10266434601203767679, tracer.ToScalar(err))
		return
	}
	for ii := uint64(0); ii < 64; ii++ {
		dst = append(dst, b.BlockRoots[ii][:]...)
		tracer.Record(18242284282990059922, tracer.ToScalar(dst))
	}

	// Field (6) 'StateRoots'
	if size := uint64(len(b.StateRoots)); size != 64 {
		err = ssz.ErrVectorLengthFn("BeaconStateBench.StateRoots", size, 64)
		tracer.Record(12938929630131233209, tracer.ToScalar(err))
		return
	}
	for ii := uint64(0); ii < 64; ii++ {
		dst = append(dst, b.StateRoots[ii][:]...)
		tracer.Record(7422940408966279896, tracer.ToScalar(dst))
	}

	// Offset (7) 'HistoricalRoots'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(7422940408966279896, tracer.ToScalar(dst))
	offset += len(b.HistoricalRoots) * 32

	tracer.Record(1655192319923618790, tracer.ToScalar(offset))

	// Field (8) 'Eth1Data'
	if dst, err = b.Eth1Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (9) 'Eth1DataVotes'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(16942987398127556103, tracer.ToScalar(dst))
	offset += len(b.Eth1DataVotes) * 72

	tracer.Record(11721367181021645439, tracer.ToScalar(offset))

	// Field (10) 'Eth1DepositIndex'
	dst = ssz.MarshalValue(dst, b.Eth1DepositIndex)

	tracer.Record(16942987398127556103, tracer.ToScalar(dst))

	// Offset (11) 'Validators'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(16942987398127556103, tracer.ToScalar(dst))
	offset += len(b.Validators) * 121

	tracer.Record(11721367181021645439, tracer.ToScalar(offset))

	// Offset (12) 'Balances'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(16942987398127556103, tracer.ToScalar(dst))
	offset += len(b.Balances) * 8

	tracer.Record(11721367181021645439, tracer.ToScalar(offset))

	// Field (13) 'RandaoMixes'
	if size := uint64(len(b.RandaoMixes)); size != 64 {
		err = ssz.ErrVectorLengthFn("BeaconStateBench.RandaoMixes", size, 64)
		tracer.Record(6250018045628651994, tracer.ToScalar(err))
		return
	}
	for ii := uint64(0); ii < 64; ii++ {
		dst = append(dst, b.RandaoMixes[ii][:]...)
		tracer.Record(1090821259119058180, tracer.ToScalar(dst))
	}

	// Field (14) 'Slashings'
	if size := uint64(len(b.Slashings)); size != 64 {
		err = ssz.ErrVectorLengthFn("BeaconStateBench.Slashings", size, 64)
		tracer.Record(16746286810655923293, tracer.ToScalar(err))
		return
	}
	for ii := uint64(0); ii < 64; ii++ {
		dst = ssz.MarshalValue(dst, uint64(b.Slashings[ii]))
		tracer.Record(5675793487236665838, tracer.ToScalar(dst))
	}

	// Offset (15) 'PreviousEpochAttestations'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(5675793487236665838, tracer.ToScalar(dst))
	for ii := 0; ii < len(b.PreviousEpochAttestations); ii++ {
		offset += 4
		tracer.Record(14586763555079182271, tracer.ToScalar(offset))
		offset += b.PreviousEpochAttestations[ii].SizeSSZ()
		tracer.Record(14586763555079182271, tracer.ToScalar(offset))
	}

	// Offset (16) 'CurrentEpochAttestations'
	dst = ssz.WriteOffset(dst, offset)

	tracer.Record(3620999717396295239, tracer.ToScalar(dst))

	// Field (17) 'JustificationBits'
	dst = append(dst, b.JustificationBits[:]...)

	tracer.Record(3620999717396295239, tracer.ToScalar(dst))

	// Field (18) 'PreviousJustifiedCheckpoint'
	if dst, err = b.PreviousJustifiedCheckpoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (19) 'CurrentJustifiedCheckpoint'
	if dst, err = b.CurrentJustifiedCheckpoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (20) 'FinalizedCheckpoint'
	if dst, err = b.FinalizedCheckpoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (7) 'HistoricalRoots'
	if size := uint64(len(b.HistoricalRoots)); size > 64 {
		err = ssz.ErrListTooBigFn("BeaconStateBench.HistoricalRoots", size, 64)
		tracer.Record(8992068812388577543, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(b.HistoricalRoots); ii++ {
		dst = append(dst, b.HistoricalRoots[ii][:]...)
		tracer.Record(1225154905329592796, tracer.ToScalar(dst))
	}

	// Field (9) 'Eth1DataVotes'
	if size := uint64(len(b.Eth1DataVotes)); size > 128 {
		err = ssz.ErrListTooBigFn("BeaconStateBench.Eth1DataVotes", size, 128)
		tracer.Record(1364664214656293109, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(b.Eth1DataVotes); ii++ {
		if dst, err = b.Eth1DataVotes[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (11) 'Validators'
	if size := uint64(len(b.Validators)); size > 128 {
		err = ssz.ErrListTooBigFn("BeaconStateBench.Validators", size, 128)
		tracer.Record(6128587941418781183, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(b.Validators); ii++ {
		if dst, err = b.Validators[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (12) 'Balances'
	if size := uint64(len(b.Balances)); size > 128 {
		err = ssz.ErrListTooBigFn("BeaconStateBench.Balances", size, 128)
		tracer.Record(9881491861973113804, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(b.Balances); ii++ {
		dst = ssz.MarshalValue(dst, uint64(b.Balances[ii]))
		tracer.Record(15900661513543213567, tracer.ToScalar(dst))
	}

	// Field (15) 'PreviousEpochAttestations'
	if size := uint64(len(b.PreviousEpochAttestations)); size > 64 {
		err = ssz.ErrListTooBigFn("BeaconStateBench.PreviousEpochAttestations", size, 64)
		tracer.Record(5207973636021131474, tracer.ToScalar(err))
		return
	}
	{
		offset = 4 * len(b.PreviousEpochAttestations)
		tracer.Record(9839015998528656905, tracer.ToScalar(offset))
		for ii := 0; ii < len(b.PreviousEpochAttestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			tracer.Record(219937087099269216, tracer.ToScalar(dst))
			offset += b.PreviousEpochAttestations[ii].SizeSSZ()
			tracer.Record(11754354498651972014, tracer.ToScalar(offset))
		}
	}
	for ii := 0; ii < len(b.PreviousEpochAttestations); ii++ {
		if dst, err = b.PreviousEpochAttestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (16) 'CurrentEpochAttestations'
	if size := uint64(len(b.CurrentEpochAttestations)); size > 64 {
		err = ssz.ErrListTooBigFn("BeaconStateBench.CurrentEpochAttestations", size, 64)
		tracer.Record(16080345031945997148, tracer.ToScalar(err))
		return
	}
	{
		offset = 4 * len(b.CurrentEpochAttestations)
		tracer.Record(4626220922698452805, tracer.ToScalar(offset))
		for ii := 0; ii < len(b.CurrentEpochAttestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			tracer.Record(17127619731891857634, tracer.ToScalar(dst))
			offset += b.CurrentEpochAttestations[ii].SizeSSZ()
			tracer.Record(12021573720187220016, tracer.ToScalar(offset))
		}
	}
	for ii := 0; ii < len(b.CurrentEpochAttestations); ii++ {
		if dst, err = b.CurrentEpochAttestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconStateBench object
func (b *BeaconStateBench) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BeaconStateBench object and returns the remaining bufferº
func (b *BeaconStateBench) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := b.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	tracer.Record(1871508765119975144, tracer.ToScalar(tail))
	var o7, o9, o11, o12, o15, o16 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	tracer.Record(10306528967774195020, tracer.ToScalar(marker))

	// Field (0) 'GenesisTime'
	b.GenesisTime, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (1) 'GenesisValidatorsRoot'
	buf = ssz.UnmarshalFixedBytes(b.GenesisValidatorsRoot[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (2) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(10826477961641141902, tracer.ToScalar(buf))
		tracer.Record(3317299527078974664, tracer.ToScalar(val))
		b.Slot = Slot(val)
	}

	// Field (3) 'Fork'
	if buf, err = b.Fork.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (4) 'LatestBlockHeader'
	if buf, err = b.LatestBlockHeader.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (5) 'BlockRoots'
	b.BlockRoots = make([][32]byte, 64)
	for ii := uint64(0); ii < 64; ii++ {
		buf = ssz.UnmarshalFixedBytes(b.BlockRoots[ii][:], buf)
		tracer.Record(2998975620494084155, tracer.ToScalar(buf))
	}

	// Field (6) 'StateRoots'
	b.StateRoots = make([][32]byte, 64)
	for ii := uint64(0); ii < 64; ii++ {
		buf = ssz.UnmarshalFixedBytes(b.StateRoots[ii][:], buf)
		tracer.Record(4703702475338618210, tracer.ToScalar(buf))
	}

	// Offset (7) 'HistoricalRoots'
	if o7, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (8) 'Eth1Data'
	if buf, err = b.Eth1Data.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Offset (9) 'Eth1DataVotes'
	if o9, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (10) 'Eth1DepositIndex'
	b.Eth1DepositIndex, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(11015653114591374222, tracer.ToScalar(buf))

	// Offset (11) 'Validators'
	if o11, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (12) 'Balances'
	if o12, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (13) 'RandaoMixes'
	b.RandaoMixes = make([][32]byte, 64)
	for ii := uint64(0); ii < 64; ii++ {
		buf = ssz.UnmarshalFixedBytes(b.RandaoMixes[ii][:], buf)
		tracer.Record(13320334932106730813, tracer.ToScalar(buf))
	}

	// Field (14) 'Slashings'
	b.Slashings = ssz.Extend(b.Slashings, 64)
	for ii := uint64(0); ii < 64; ii++ {
		{
			var val uint64
			val, buf = ssz.UnmarshallValue[uint64](buf)
			tracer.Record(3188150773444316475, tracer.ToScalar(buf))
			tracer.Record(14095040038170669153, tracer.ToScalar(val))
			b.Slashings[ii] = Gwei(val)
		}
	}

	// Offset (15) 'PreviousEpochAttestations'
	if o15, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (16) 'CurrentEpochAttestations'
	if o16, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (17) 'JustificationBits'
	buf = ssz.UnmarshalFixedBytes(b.JustificationBits[:], buf)

	tracer.Record(10143564518235006577, tracer.ToScalar(buf))

	// Field (18) 'PreviousJustifiedCheckpoint'
	if buf, err = b.PreviousJustifiedCheckpoint.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (19) 'CurrentJustifiedCheckpoint'
	if buf, err = b.CurrentJustifiedCheckpoint.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (20) 'FinalizedCheckpoint'
	if buf, err = b.FinalizedCheckpoint.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (7) 'HistoricalRoots'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.HistoricalRoots, tail[o7:o9], 32, 64, func(ii uint64, buf []byte) (err error) {
		buf = ssz.UnmarshalFixedBytes(b.HistoricalRoots[ii][:], buf)
		tracer.Record(11091695613889631122, tracer.ToScalar(buf))
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (9) 'Eth1DataVotes'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.Eth1DataVotes, tail[o9:o11], 72, 128, func(ii uint64, buf []byte) (err error) {
		if buf, err = b.Eth1DataVotes[ii].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (11) 'Validators'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.Validators, tail[o11:o12], 121, 128, func(ii uint64, buf []byte) (err error) {
		if buf, err = b.Validators[ii].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (12) 'Balances'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.Balances, tail[o12:o15], 8, 128, func(ii uint64, buf []byte) (err error) {
		{
			var val uint64
			val, buf = ssz.UnmarshallValue[uint64](buf)
			tracer.Record(7197762166812001780, tracer.ToScalar(buf))
			tracer.Record(1215343590981129882, tracer.ToScalar(val))
			b.Balances[ii] = Gwei(val)
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (15) 'PreviousEpochAttestations'
	if err = ssz.UnmarshalDynamicSliceWithCallback(&b.PreviousEpochAttestations, tail[o15:o16], 64, func(indx uint64, buf []byte) (err error) {
		if buf, err = b.PreviousEpochAttestations[indx].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (16) 'CurrentEpochAttestations'
	if err = ssz.UnmarshalDynamicSliceWithCallback(&b.CurrentEpochAttestations, tail[o16:], 64, func(indx uint64, buf []byte) (err error) {
		if buf, err = b.CurrentEpochAttestations[indx].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BeaconStateBench object
func (b *BeaconStateBench) fixedSize() int {
	return int(7057)
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconStateBench object
func (b *BeaconStateBench) SizeSSZ() (size int) {
	size = b.fixedSize()

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (7) 'HistoricalRoots'
	size += len(b.HistoricalRoots) * 32

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (9) 'Eth1DataVotes'
	size += len(b.Eth1DataVotes) * 72

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (11) 'Validators'
	size += len(b.Validators) * 121

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (12) 'Balances'
	size += len(b.Balances) * 8

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (15) 'PreviousEpochAttestations'
	for ii := 0; ii < len(b.PreviousEpochAttestations); ii++ {
		size += 4
		tracer.Record(12311935605700098293, tracer.ToScalar(size))
		size += b.PreviousEpochAttestations[ii].SizeSSZ()
		tracer.Record(12311935605700098293, tracer.ToScalar(size))
	}

	// Field (16) 'CurrentEpochAttestations'
	for ii := 0; ii < len(b.CurrentEpochAttestations); ii++ {
		size += 4
		tracer.Record(1539179975960296358, tracer.ToScalar(size))
		size += b.CurrentEpochAttestations[ii].SizeSSZ()
		tracer.Record(1539179975960296358, tracer.ToScalar(size))
	}

	return
}

// HashTreeRoot ssz hashes the BeaconStateBench object
func (b *BeaconStateBench) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconStateBench object with a hasher
func (b *BeaconStateBench) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'GenesisTime'
	hh.PutUint64(b.GenesisTime)

	// Field (1) 'GenesisValidatorsRoot'
	hh.PutBytes(b.GenesisValidatorsRoot[:])

	// Field (2) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (3) 'Fork'
	if err = b.Fork.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'LatestBlockHeader'
	if err = b.LatestBlockHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (5) 'BlockRoots'
	{
		if size := uint64(len(b.BlockRoots)); size != 64 {
			err = ssz.ErrVectorLengthFn("BeaconStateBench.BlockRoots", size, 64)
			tracer.Record(13786133570086949013, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(5655751409261689611, tracer.ToScalar(subIndx))
		for _, i := range b.BlockRoots {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (6) 'StateRoots'
	{
		if size := uint64(len(b.StateRoots)); size != 64 {
			err = ssz.ErrVectorLengthFn("BeaconStateBench.StateRoots", size, 64)
			tracer.Record(14897504709158182664, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(15277873452446992942, tracer.ToScalar(subIndx))
		for _, i := range b.StateRoots {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (7) 'HistoricalRoots'
	{
		if size := uint64(len(b.HistoricalRoots)); size > 64 {
			err = ssz.ErrListTooBigFn("BeaconStateBench.HistoricalRoots", size, 64)
			tracer.Record(15159811435473678396, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(14215596369132501442, tracer.ToScalar(subIndx))
		for _, i := range b.HistoricalRoots {
			hh.Append(i[:])
		}
		numItems := uint64(len(b.HistoricalRoots))
		tracer.Record(7750978874842916384, tracer.ToScalar(numItems))
		hh.MerkleizeWithMixin(subIndx, numItems, 64)
	}

	// Field (8) 'Eth1Data'
	if err = b.Eth1Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (9) 'Eth1DataVotes'
	{
		subIndx := hh.Index()
		tracer.Record(5141894742104441215, tracer.ToScalar(subIndx))
		num := uint64(len(b.Eth1DataVotes))
		tracer.Record(17202870987189103038, tracer.ToScalar(num))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(17072548119408078320, tracer.ToScalar(err))
			return
		}
		for _, elem := range b.Eth1DataVotes {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (10) 'Eth1DepositIndex'
	hh.PutUint64(b.Eth1DepositIndex)

	// Field (11) 'Validators'
	{
		subIndx := hh.Index()
		tracer.Record(17375559341245453747, tracer.ToScalar(subIndx))
		num := uint64(len(b.Validators))
		tracer.Record(5982997374800800242, tracer.ToScalar(num))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(5860300719671533220, tracer.ToScalar(err))
			return
		}
		for _, elem := range b.Validators {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (12) 'Balances'
	{
		if size := uint64(len(b.Balances)); size > 128 {
			err = ssz.ErrListTooBigFn("BeaconStateBench.Balances", size, 128)
			tracer.Record(17420409180563790303, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(16467419987275299529, tracer.ToScalar(subIndx))
		for _, i := range b.Balances {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(b.Balances))
		tracer.Record(13339893016079246245, tracer.ToScalar(numItems))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(128, numItems, 8))
	}

	// Field (13) 'RandaoMixes'
	{
		if size := uint64(len(b.RandaoMixes)); size != 64 {
			err = ssz.ErrVectorLengthFn("BeaconStateBench.RandaoMixes", size, 64)
			tracer.Record(16499513400189318578, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(5780364612055911996, tracer.ToScalar(subIndx))
		for _, i := range b.RandaoMixes {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (14) 'Slashings'
	{
		if size := uint64(len(b.Slashings)); size != 64 {
			err = ssz.ErrVectorLengthFn("BeaconStateBench.Slashings", size, 64)
			tracer.Record(1725747471913515361, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(1653343155214830087, tracer.ToScalar(subIndx))
		for _, i := range b.Slashings {
			hh.AppendUint64(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (15) 'PreviousEpochAttestations'
	{
		subIndx := hh.Index()
		tracer.Record(15532236773711478816, tracer.ToScalar(subIndx))
		num := uint64(len(b.PreviousEpochAttestations))
		tracer.Record(4398277150638019793, tracer.ToScalar(num))
		if num > 64 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(16824557396040937289, tracer.ToScalar(err))
			return
		}
		for _, elem := range b.PreviousEpochAttestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 64)
	}

	// Field (16) 'CurrentEpochAttestations'
	{
		subIndx := hh.Index()
		tracer.Record(12579376904838881740, tracer.ToScalar(subIndx))
		num := uint64(len(b.CurrentEpochAttestations))
		tracer.Record(4565790097903048685, tracer.ToScalar(num))
		if num > 64 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(3429418469157365381, tracer.ToScalar(err))
			return
		}
		for _, elem := range b.CurrentEpochAttestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 64)
	}

	// Field (17) 'JustificationBits'
	hh.PutBytes(b.JustificationBits[:])

	// Field (18) 'PreviousJustifiedCheckpoint'
	if err = b.PreviousJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (19) 'CurrentJustifiedCheckpoint'
	if err = b.CurrentJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (20) 'FinalizedCheckpoint'
	if err = b.FinalizedCheckpoint.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconStateBench object
func (b *BeaconStateBench) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the ValidatorEnvelope object
func (v *ValidatorEnvelope) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the ValidatorEnvelope object to a target array
func (v *ValidatorEnvelope) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	tracer.Record(10095149564870410566, tracer.ToScalar(dst))
	offset := v.fixedSize()

	tracer.Record(642677820169046180, tracer.ToScalar(offset))

	// Field (0) 'Slashed'
	dst = ssz.MarshalValue(dst, v.Slashed)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'Pubkey'
	dst = append(dst, v.Pubkey[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (2) 'WithdrawalCredentials'
	dst = append(dst, v.WithdrawalCredentials[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (3) 'EffectiveBalance'
	dst = ssz.MarshalValue(dst, uint64(v.EffectiveBalance))

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (4) 'ActivationEligibilityEpoch'
	dst = ssz.MarshalValue(dst, v.ActivationEligibilityEpoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (5) 'ActivationEpoch'
	dst = ssz.MarshalValue(dst, v.ActivationEpoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (6) 'ExitEpoch'
	dst = ssz.MarshalValue(dst, v.ExitEpoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (7) 'WithdrawableEpoch'
	dst = ssz.MarshalValue(dst, v.WithdrawableEpoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Offset (8) 'Balances'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(10095149564870410566, tracer.ToScalar(dst))
	offset += len(v.Balances) * 8

	tracer.Record(642677820169046180, tracer.ToScalar(offset))

	// Field (9) 'RandaoMixes'
	if size := uint64(len(v.RandaoMixes)); size != 64 {
		err = ssz.ErrVectorLengthFn("ValidatorEnvelope.RandaoMixes", size, 64)
		tracer.Record(2719180289556938421, tracer.ToScalar(err))
		return
	}
	for ii := uint64(0); ii < 64; ii++ {
		dst = append(dst, v.RandaoMixes[ii][:]...)
		tracer.Record(14547142586060853660, tracer.ToScalar(dst))
	}

	// Field (10) 'Slashings'
	if size := uint64(len(v.Slashings)); size != 64 {
		err = ssz.ErrVectorLengthFn("ValidatorEnvelope.Slashings", size, 64)
		tracer.Record(10266434601203767679, tracer.ToScalar(err))
		return
	}
	for ii := uint64(0); ii < 64; ii++ {
		dst = ssz.MarshalValue(dst, uint64(v.Slashings[ii]))
		tracer.Record(18242284282990059922, tracer.ToScalar(dst))
	}

	// Offset (11) 'Eth1DataVotes'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(18242284282990059922, tracer.ToScalar(dst))
	offset += len(v.Eth1DataVotes) * 72

	tracer.Record(3623585332182080704, tracer.ToScalar(offset))

	// Offset (12) 'PendingAttestations'
	dst = ssz.WriteOffset(dst, offset)

	tracer.Record(18242284282990059922, tracer.ToScalar(dst))

	// Field (13) 'SyncCommitteeRoots'
	if size := uint64(len(v.SyncCommitteeRoots)); size != 64 {
		err = ssz.ErrVectorLengthFn("ValidatorEnvelope.SyncCommitteeRoots", size, 64)
		tracer.Record(12938929630131233209, tracer.ToScalar(err))
		return
	}
	for ii := uint64(0); ii < 64; ii++ {
		dst = append(dst, v.SyncCommitteeRoots[ii][:]...)
		tracer.Record(7422940408966279896, tracer.ToScalar(dst))
	}

	// Field (8) 'Balances'
	if size := uint64(len(v.Balances)); size > 1024 {
		err = ssz.ErrListTooBigFn("ValidatorEnvelope.Balances", size, 1024)
		tracer.Record(17470496793313948915, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(v.Balances); ii++ {
		dst = ssz.MarshalValue(dst, uint64(v.Balances[ii]))
		tracer.Record(7030028087160489134, tracer.ToScalar(dst))
	}

	// Field (11) 'Eth1DataVotes'
	if size := uint64(len(v.Eth1DataVotes)); size > 128 {
		err = ssz.ErrListTooBigFn("ValidatorEnvelope.Eth1DataVotes", size, 128)
		tracer.Record(563298669793126836, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(v.Eth1DataVotes); ii++ {
		if dst, err = v.Eth1DataVotes[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (12) 'PendingAttestations'
	if size := uint64(len(v.PendingAttestations)); size > 64 {
		err = ssz.ErrListTooBigFn("ValidatorEnvelope.PendingAttestations", size, 64)
		tracer.Record(4148509112582688051, tracer.ToScalar(err))
		return
	}
	{
		offset = 4 * len(v.PendingAttestations)
		tracer.Record(14831049136538867566, tracer.ToScalar(offset))
		for ii := 0; ii < len(v.PendingAttestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			tracer.Record(17394212371014325993, tracer.ToScalar(dst))
			offset += v.PendingAttestations[ii].SizeSSZ()
			tracer.Record(8168250964025370057, tracer.ToScalar(offset))
		}
	}
	for ii := 0; ii < len(v.PendingAttestations); ii++ {
		if dst, err = v.PendingAttestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ValidatorEnvelope object
func (v *ValidatorEnvelope) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(v, buf)
}

// UnmarshalSSZTail unmarshals the ValidatorEnvelope object and returns the remaining bufferº
func (v *ValidatorEnvelope) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := v.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	tracer.Record(1871508765119975144, tracer.ToScalar(tail))
	var o8, o11, o12 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	tracer.Record(10306528967774195020, tracer.ToScalar(marker))

	// Field (0) 'Slashed'
	if err = ssz.IsValidBool(buf); err != nil {
		return
	}
	v.Slashed, buf = ssz.UnmarshallValue[bool](buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	// Field (1) 'Pubkey'
	buf = ssz.UnmarshalFixedBytes(v.Pubkey[:], buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	// Field (2) 'WithdrawalCredentials'
	buf = ssz.UnmarshalFixedBytes(v.WithdrawalCredentials[:], buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	// Field (3) 'EffectiveBalance'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(9954389365284774257, tracer.ToScalar(buf))
		tracer.Record(17486380467104521923, tracer.ToScalar(val))
		v.EffectiveBalance = Gwei(val)
	}

	// Field (4) 'ActivationEligibilityEpoch'
	v.ActivationEligibilityEpoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (5) 'ActivationEpoch'
	v.ActivationEpoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (6) 'ExitEpoch'
	v.ExitEpoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (7) 'WithdrawableEpoch'
	v.WithdrawableEpoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Offset (8) 'Balances'
	if o8, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (9) 'RandaoMixes'
	v.RandaoMixes = make([][32]byte, 64)
	for ii := uint64(0); ii < 64; ii++ {
		buf = ssz.UnmarshalFixedBytes(v.RandaoMixes[ii][:], buf)
		tracer.Record(2998975620494084155, tracer.ToScalar(buf))
	}

	// Field (10) 'Slashings'
	v.Slashings = ssz.Extend(v.Slashings, 64)
	for ii := uint64(0); ii < 64; ii++ {
		{
			var val uint64
			val, buf = ssz.UnmarshallValue[uint64](buf)
			tracer.Record(13241674178360573445, tracer.ToScalar(buf))
			tracer.Record(5678786799794151879, tracer.ToScalar(val))
			v.Slashings[ii] = Gwei(val)
		}
	}

	// Offset (11) 'Eth1DataVotes'
	if o11, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (12) 'PendingAttestations'
	if o12, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (13) 'SyncCommitteeRoots'
	v.SyncCommitteeRoots = make([]Root, 64)
	for ii := uint64(0); ii < 64; ii++ {
		buf = ssz.UnmarshalFixedBytes(v.SyncCommitteeRoots[ii][:], buf)
		tracer.Record(161212721691361511, tracer.ToScalar(buf))
	}

	// Field (8) 'Balances'
	if err = ssz.UnmarshalSliceWithIndexCallback(&v.Balances, tail[o8:o11], 8, 1024, func(ii uint64, buf []byte) (err error) {
		{
			var val uint64
			val, buf = ssz.UnmarshallValue[uint64](buf)
			tracer.Record(13320334932106730813, tracer.ToScalar(buf))
			tracer.Record(7345265491997307439, tracer.ToScalar(val))
			v.Balances[ii] = Gwei(val)
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (11) 'Eth1DataVotes'
	if err = ssz.UnmarshalSliceWithIndexCallback(&v.Eth1DataVotes, tail[o11:o12], 72, 128, func(ii uint64, buf []byte) (err error) {
		if buf, err = v.Eth1DataVotes[ii].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (12) 'PendingAttestations'
	if err = ssz.UnmarshalDynamicSliceWithCallback(&v.PendingAttestations, tail[o12:], 64, func(indx uint64, buf []byte) (err error) {
		if buf, err = v.PendingAttestations[indx].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the ValidatorEnvelope object
func (v *ValidatorEnvelope) fixedSize() int {
	return int(4741)
}

// SizeSSZ returns the ssz encoded size in bytes for the ValidatorEnvelope object
func (v *ValidatorEnvelope) SizeSSZ() (size int) {
	size = v.fixedSize()

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (8) 'Balances'
	size += len(v.Balances) * 8

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (11) 'Eth1DataVotes'
	size += len(v.Eth1DataVotes) * 72

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (12) 'PendingAttestations'
	for ii := 0; ii < len(v.PendingAttestations); ii++ {
		size += 4
		tracer.Record(12311935605700098293, tracer.ToScalar(size))
		size += v.PendingAttestations[ii].SizeSSZ()
		tracer.Record(12311935605700098293, tracer.ToScalar(size))
	}

	return
}

// HashTreeRoot ssz hashes the ValidatorEnvelope object
func (v *ValidatorEnvelope) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the ValidatorEnvelope object with a hasher
func (v *ValidatorEnvelope) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Slashed'
	hh.PutBool(v.Slashed)

	// Field (1) 'Pubkey'
	hh.PutBytes(v.Pubkey[:])

	// Field (2) 'WithdrawalCredentials'
	hh.PutBytes(v.WithdrawalCredentials[:])

	// Field (3) 'EffectiveBalance'
	hh.PutUint64(uint64(v.EffectiveBalance))

	// Field (4) 'ActivationEligibilityEpoch'
	hh.PutUint64(v.ActivationEligibilityEpoch)

	// Field (5) 'ActivationEpoch'
	hh.PutUint64(v.ActivationEpoch)

	// Field (6) 'ExitEpoch'
	hh.PutUint64(v.ExitEpoch)

	// Field (7) 'WithdrawableEpoch'
	hh.PutUint64(v.WithdrawableEpoch)

	// Field (8) 'Balances'
	{
		if size := uint64(len(v.Balances)); size > 1024 {
			err = ssz.ErrListTooBigFn("ValidatorEnvelope.Balances", size, 1024)
			tracer.Record(3131808512787760991, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(2269996082009391177, tracer.ToScalar(subIndx))
		for _, i := range v.Balances {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(v.Balances))
		tracer.Record(16869105451348065317, tracer.ToScalar(numItems))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(1024, numItems, 8))
	}

	// Field (9) 'RandaoMixes'
	{
		if size := uint64(len(v.RandaoMixes)); size != 64 {
			err = ssz.ErrVectorLengthFn("ValidatorEnvelope.RandaoMixes", size, 64)
			tracer.Record(2210912732413289266, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(10029684780499555260, tracer.ToScalar(subIndx))
		for _, i := range v.RandaoMixes {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (10) 'Slashings'
	{
		if size := uint64(len(v.Slashings)); size != 64 {
			err = ssz.ErrVectorLengthFn("ValidatorEnvelope.Slashings", size, 64)
			tracer.Record(5883890877847037665, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(5902663323658473351, tracer.ToScalar(subIndx))
		for _, i := range v.Slashings {
			hh.AppendUint64(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (11) 'Eth1DataVotes'
	{
		subIndx := hh.Index()
		tracer.Record(14215596369132501442, tracer.ToScalar(subIndx))
		num := uint64(len(v.Eth1DataVotes))
		tracer.Record(3487842397611938147, tracer.ToScalar(num))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(3259781592892722107, tracer.ToScalar(err))
			return
		}
		for _, elem := range v.Eth1DataVotes {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (12) 'PendingAttestations'
	{
		subIndx := hh.Index()
		tracer.Record(7814564950403441894, tracer.ToScalar(subIndx))
		num := uint64(len(v.PendingAttestations))
		tracer.Record(13944883939693290311, tracer.ToScalar(num))
		if num > 64 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(5172518276827122031, tracer.ToScalar(err))
			return
		}
		for _, elem := range v.PendingAttestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 64)
	}

	// Field (13) 'SyncCommitteeRoots'
	{
		if size := uint64(len(v.SyncCommitteeRoots)); size != 64 {
			err = ssz.ErrVectorLengthFn("ValidatorEnvelope.SyncCommitteeRoots", size, 64)
			tracer.Record(13804482780934581792, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(16608366881390124534, tracer.ToScalar(subIndx))
		for _, i := range v.SyncCommitteeRoots {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ValidatorEnvelope object
func (v *ValidatorEnvelope) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the AttestationEnvelope object
func (a *AttestationEnvelope) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttestationEnvelope object to a target array
func (a *AttestationEnvelope) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	tracer.Record(10095149564870410566, tracer.ToScalar(dst))
	offset := a.fixedSize()

	tracer.Record(642677820169046180, tracer.ToScalar(offset))

	// Offset (0) 'AggregationBits'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(10095149564870410566, tracer.ToScalar(dst))
	offset += len(a.AggregationBits)

	tracer.Record(642677820169046180, tracer.ToScalar(offset))

	// Field (1) 'Data'
	if dst, err = a.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Signature'
	dst = append(dst, a.Signature[:]...)

	tracer.Record(1938884375001766421, tracer.ToScalar(dst))

	// Field (3) 'CommitteeIndex'
	dst = ssz.MarshalValue(dst, a.CommitteeIndex)

	tracer.Record(1938884375001766421, tracer.ToScalar(dst))

	// Offset (4) 'AttestingIndices'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(1938884375001766421, tracer.ToScalar(dst))
	offset += len(a.AttestingIndices) * 8

	tracer.Record(4853196169973298709, tracer.ToScalar(offset))

	// Offset (5) 'CustodyBits'
	dst = ssz.WriteOffset(dst, offset)

	tracer.Record(1938884375001766421, tracer.ToScalar(dst))

	// Field (0) 'AggregationBits'
	if size := ssz.BitlistLen(a.AggregationBits); size > 2048 {
		err = ssz.ErrBytesLengthFn("AttestationEnvelope.AggregationBits", size, 2048)
		tracer.Record(14019338521758100300, tracer.ToScalar(err))
		return
	}
	dst = append(dst, a.AggregationBits...)

	tracer.Record(14547142586060853660, tracer.ToScalar(dst))

	// Field (4) 'AttestingIndices'
	if size := uint64(len(a.AttestingIndices)); size > 2048 {
		err = ssz.ErrListTooBigFn("AttestationEnvelope.AttestingIndices", size, 2048)
		tracer.Record(10266434601203767679, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(a.AttestingIndices); ii++ {
		dst = ssz.MarshalValue(dst, uint64(a.AttestingIndices[ii]))
		tracer.Record(18242284282990059922, tracer.ToScalar(dst))
	}

	// Field (5) 'CustodyBits'
	if size := ssz.BitlistLen(a.CustodyBits); size > 2048 {
		err = ssz.ErrBytesLengthFn("AttestationEnvelope.CustodyBits", size, 2048)
		tracer.Record(12938929630131233209, tracer.ToScalar(err))
		return
	}
	dst = append(dst, a.CustodyBits...)

	tracer.Record(12403543333641850593, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the AttestationEnvelope object
func (a *AttestationEnvelope) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(a, buf)
}

// UnmarshalSSZTail unmarshals the AttestationEnvelope object and returns the remaining bufferº
func (a *AttestationEnvelope) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := a.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	tracer.Record(1871508765119975144, tracer.ToScalar(tail))
	var o0, o4, o5 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	tracer.Record(10306528967774195020, tracer.ToScalar(marker))

	// Offset (0) 'AggregationBits'
	if o0, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'Data'
	if buf, err = a.Data.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (2) 'Signature'
	buf = ssz.UnmarshalFixedBytes(a.Signature[:], buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Field (3) 'CommitteeIndex'
	a.CommitteeIndex, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(9954389365284774257, tracer.ToScalar(buf))

	// Offset (4) 'AttestingIndices'
	if o4, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (5) 'CustodyBits'
	if o5, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (0) 'AggregationBits'
	if a.AggregationBits, err = ssz.UnmarshalBitList(a.AggregationBits, tail[o0:o4], 2048); err != nil {
		return nil, err
	}

	// Field (4) 'AttestingIndices'
	if err = ssz.UnmarshalSliceWithIndexCallback(&a.AttestingIndices, tail[o4:o5], 8, 2048, func(ii uint64, buf []byte) (err error) {
		{
			var val uint64
			val, buf = ssz.UnmarshallValue[uint64](buf)
			tracer.Record(9754023341032717460, tracer.ToScalar(buf))
			tracer.Record(3771604765201845562, tracer.ToScalar(val))
			a.AttestingIndices[ii] = ValidatorIndex(val)
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (5) 'CustodyBits'
	if a.CustodyBits, err = ssz.UnmarshalBitList(a.CustodyBits, tail[o5:], 2048); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the AttestationEnvelope object
func (a *AttestationEnvelope) fixedSize() int {
	return int(244)
}

// SizeSSZ returns the ssz encoded size in bytes for the AttestationEnvelope object
func (a *AttestationEnvelope) SizeSSZ() (size int) {
	size = a.fixedSize()

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (0) 'AggregationBits'
	size += len(a.AggregationBits)

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (4) 'AttestingIndices'
	size += len(a.AttestingIndices) * 8

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (5) 'CustodyBits'
	size += len(a.CustodyBits)

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	return
}

// HashTreeRoot ssz hashes the AttestationEnvelope object
func (a *AttestationEnvelope) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttestationEnvelope object with a hasher
func (a *AttestationEnvelope) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'AggregationBits'
	if len(a.AggregationBits) == 0 {
		err = ssz.ErrEmptyBitlist
		tracer.Record(10327639356949190406, tracer.ToScalar(err))
		return
	}
	hh.PutBitlist(a.AggregationBits, 2048)

	// Field (1) 'Data'
	if err = a.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Signature'
	hh.PutBytes(a.Signature[:])

	// Field (3) 'CommitteeIndex'
	hh.PutUint64(a.CommitteeIndex)

	// Field (4) 'AttestingIndices'
	{
		if size := uint64(len(a.AttestingIndices)); size > 2048 {
			err = ssz.ErrListTooBigFn("AttestationEnvelope.AttestingIndices", size, 2048)
			tracer.Record(13786133570086949013, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(5655751409261689611, tracer.ToScalar(subIndx))
		for _, i := range a.AttestingIndices {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(a.AttestingIndices))
		tracer.Record(5893116258816430551, tracer.ToScalar(numItems))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(2048, numItems, 8))
	}

	// Field (5) 'CustodyBits'
	if len(a.CustodyBits) == 0 {
		err = ssz.ErrEmptyBitlist
		tracer.Record(1219071828853361067, tracer.ToScalar(err))
		return
	}
	hh.PutBitlist(a.CustodyBits, 2048)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AttestationEnvelope object
func (a *AttestationEnvelope) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedBeaconBlockHeader object to a target array
func (s *SignedBeaconBlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Message'
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	tracer.Record(1938884375001766421, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(s, buf)
}

// UnmarshalSSZTail unmarshals the SignedBeaconBlockHeader object and returns the remaining bufferº
func (s *SignedBeaconBlockHeader) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := s.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Message'
	if buf, err = s.Message.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (1) 'Signature'
	buf = ssz.UnmarshalFixedBytes(s.Signature[:], buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	return buf, nil
}

// fixedSize returns the fixed size of the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) fixedSize() int {
	return int(208)
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) SizeSSZ() (size int) {
	size = s.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedBeaconBlockHeader object with a hasher
func (s *SignedBeaconBlockHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedBeaconBlockHeader object
func (s *SignedBeaconBlockHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the ProposerSlashing object
func (p *ProposerSlashing) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProposerSlashing object to a target array
func (p *ProposerSlashing) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Header1'
	if dst, err = p.Header1.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Header2'
	if dst, err = p.Header2.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ProposerSlashing object
func (p *ProposerSlashing) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(p, buf)
}

// UnmarshalSSZTail unmarshals the ProposerSlashing object and returns the remaining bufferº
func (p *ProposerSlashing) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := p.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Header1'
	if buf, err = p.Header1.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (1) 'Header2'
	if buf, err = p.Header2.UnmarshalSSZTail(buf); err != nil {
		return
	}

	return buf, nil
}

// fixedSize returns the fixed size of the ProposerSlashing object
func (p *ProposerSlashing) fixedSize() int {
	return int(416)
}

// SizeSSZ returns the ssz encoded size in bytes for the ProposerSlashing object
func (p *ProposerSlashing) SizeSSZ() (size int) {
	size = p.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the ProposerSlashing object
func (p *ProposerSlashing) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the ProposerSlashing object with a hasher
func (p *ProposerSlashing) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Header1'
	if err = p.Header1.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Header2'
	if err = p.Header2.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ProposerSlashing object
func (p *ProposerSlashing) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the SignedAttestationData object
func (s *SignedAttestationData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedAttestationData object to a target array
func (s *SignedAttestationData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Data'
	if dst, err = s.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	tracer.Record(1938884375001766421, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the SignedAttestationData object
func (s *SignedAttestationData) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(s, buf)
}

// UnmarshalSSZTail unmarshals the SignedAttestationData object and returns the remaining bufferº
func (s *SignedAttestationData) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := s.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Data'
	if buf, err = s.Data.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (1) 'Signature'
	buf = ssz.UnmarshalFixedBytes(s.Signature[:], buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	return buf, nil
}

// fixedSize returns the fixed size of the SignedAttestationData object
func (s *SignedAttestationData) fixedSize() int {
	return int(224)
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedAttestationData object
func (s *SignedAttestationData) SizeSSZ() (size int) {
	size = s.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the SignedAttestationData object
func (s *SignedAttestationData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedAttestationData object with a hasher
func (s *SignedAttestationData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Data'
	if err = s.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedAttestationData object
func (s *SignedAttestationData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the AttesterSlashing object
func (a *AttesterSlashing) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttesterSlashing object to a target array
func (a *AttesterSlashing) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Att1'
	if dst, err = a.Att1.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Att2'
	if dst, err = a.Att2.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AttesterSlashing object
func (a *AttesterSlashing) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(a, buf)
}

// UnmarshalSSZTail unmarshals the AttesterSlashing object and returns the remaining bufferº
func (a *AttesterSlashing) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := a.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Att1'
	if buf, err = a.Att1.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (1) 'Att2'
	if buf, err = a.Att2.UnmarshalSSZTail(buf); err != nil {
		return
	}

	return buf, nil
}

// fixedSize returns the fixed size of the AttesterSlashing object
func (a *AttesterSlashing) fixedSize() int {
	return int(448)
}

// SizeSSZ returns the ssz encoded size in bytes for the AttesterSlashing object
func (a *AttesterSlashing) SizeSSZ() (size int) {
	size = a.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the AttesterSlashing object
func (a *AttesterSlashing) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttesterSlashing object with a hasher
func (a *AttesterSlashing) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Att1'
	if err = a.Att1.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Att2'
	if err = a.Att2.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AttesterSlashing object
func (a *AttesterSlashing) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the DepositData object
func (d *DepositData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the DepositData object to a target array
func (d *DepositData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Pubkey'
	dst = append(dst, d.Pubkey[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'WithdrawalCredentials'
	dst = append(dst, d.WithdrawalCredentials[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (2) 'Amount'
	dst = ssz.MarshalValue(dst, uint64(d.Amount))

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (3) 'Signature'
	dst = append(dst, d.Signature[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the DepositData object
func (d *DepositData) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(d, buf)
}

// UnmarshalSSZTail unmarshals the DepositData object and returns the remaining bufferº
func (d *DepositData) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := d.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Pubkey'
	buf = ssz.UnmarshalFixedBytes(d.Pubkey[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (1) 'WithdrawalCredentials'
	buf = ssz.UnmarshalFixedBytes(d.WithdrawalCredentials[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (2) 'Amount'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(10826477961641141902, tracer.ToScalar(buf))
		tracer.Record(3317299527078974664, tracer.ToScalar(val))
		d.Amount = Gwei(val)
	}

	// Field (3) 'Signature'
	buf = ssz.UnmarshalFixedBytes(d.Signature[:], buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	return buf, nil
}

// fixedSize returns the fixed size of the DepositData object
func (d *DepositData) fixedSize() int {
	return int(184)
}

// SizeSSZ returns the ssz encoded size in bytes for the DepositData object
func (d *DepositData) SizeSSZ() (size int) {
	size = d.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the DepositData object
func (d *DepositData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the DepositData object with a hasher
func (d *DepositData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Pubkey'
	hh.PutBytes(d.Pubkey[:])

	// Field (1) 'WithdrawalCredentials'
	hh.PutBytes(d.WithdrawalCredentials[:])

	// Field (2) 'Amount'
	hh.PutUint64(uint64(d.Amount))

	// Field (3) 'Signature'
	hh.PutBytes(d.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the DepositData object
func (d *DepositData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the Deposit object
func (d *Deposit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the Deposit object to a target array
func (d *Deposit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Proof'
	for ii := uint64(0); ii < 4; ii++ {
		dst = append(dst, d.Proof[ii][:]...)
		tracer.Record(1938884375001766421, tracer.ToScalar(dst))
	}

	// Field (1) 'Data'
	if dst, err = d.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Deposit object
func (d *Deposit) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(d, buf)
}

// UnmarshalSSZTail unmarshals the Deposit object and returns the remaining bufferº
func (d *Deposit) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := d.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Proof'

	for ii := uint64(0); ii < 4; ii++ {
		buf = ssz.UnmarshalFixedBytes(d.Proof[ii][:], buf)
		tracer.Record(10826477961641141902, tracer.ToScalar(buf))
	}

	// Field (1) 'Data'
	if buf, err = d.Data.UnmarshalSSZTail(buf); err != nil {
		return
	}

	return buf, nil
}

// fixedSize returns the fixed size of the Deposit object
func (d *Deposit) fixedSize() int {
	return int(312)
}

// SizeSSZ returns the ssz encoded size in bytes for the Deposit object
func (d *Deposit) SizeSSZ() (size int) {
	size = d.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the Deposit object
func (d *Deposit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the Deposit object with a hasher
func (d *Deposit) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Proof'
	{
		subIndx := hh.Index()
		tracer.Record(11371677713040014224, tracer.ToScalar(subIndx))
		for _, i := range d.Proof {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'Data'
	if err = d.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Deposit object
func (d *Deposit) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the VoluntaryExit object
func (v *VoluntaryExit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the VoluntaryExit object to a target array
func (v *VoluntaryExit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Epoch'
	dst = ssz.MarshalValue(dst, v.Epoch)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'ValidatorIndex'
	dst = ssz.MarshalValue(dst, uint64(v.ValidatorIndex))

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the VoluntaryExit object
func (v *VoluntaryExit) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(v, buf)
}

// UnmarshalSSZTail unmarshals the VoluntaryExit object and returns the remaining bufferº
func (v *VoluntaryExit) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := v.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Epoch'
	v.Epoch, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (1) 'ValidatorIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(10826477961641141902, tracer.ToScalar(buf))
		tracer.Record(3317299527078974664, tracer.ToScalar(val))
		v.ValidatorIndex = ValidatorIndex(val)
	}

	return buf, nil
}

// fixedSize returns the fixed size of the VoluntaryExit object
func (v *VoluntaryExit) fixedSize() int {
	return int(16)
}

// SizeSSZ returns the ssz encoded size in bytes for the VoluntaryExit object
func (v *VoluntaryExit) SizeSSZ() (size int) {
	size = v.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the VoluntaryExit object
func (v *VoluntaryExit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the VoluntaryExit object with a hasher
func (v *VoluntaryExit) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Epoch'
	hh.PutUint64(v.Epoch)

	// Field (1) 'ValidatorIndex'
	hh.PutUint64(uint64(v.ValidatorIndex))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the VoluntaryExit object
func (v *VoluntaryExit) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SignedVoluntaryExit object to a target array
func (s *SignedVoluntaryExit) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (0) 'Message'
	if dst, err = s.Message.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Signature'
	dst = append(dst, s.Signature[:]...)

	tracer.Record(1938884375001766421, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(s, buf)
}

// UnmarshalSSZTail unmarshals the SignedVoluntaryExit object and returns the remaining bufferº
func (s *SignedVoluntaryExit) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := s.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Message'
	if buf, err = s.Message.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (1) 'Signature'
	buf = ssz.UnmarshalFixedBytes(s.Signature[:], buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	return buf, nil
}

// fixedSize returns the fixed size of the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) fixedSize() int {
	return int(112)
}

// SizeSSZ returns the ssz encoded size in bytes for the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) SizeSSZ() (size int) {
	size = s.fixedSize()
	tracer.Record(12478871526554291020, tracer.ToScalar(size))
	return
}

// HashTreeRoot ssz hashes the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SignedVoluntaryExit object with a hasher
func (s *SignedVoluntaryExit) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'Message'
	if err = s.Message.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Signature'
	hh.PutBytes(s.Signature[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SignedVoluntaryExit object
func (s *SignedVoluntaryExit) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the BlockBodyBench object
func (b *BlockBodyBench) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockBodyBench object to a target array
func (b *BlockBodyBench) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	tracer.Record(10095149564870410566, tracer.ToScalar(dst))
	offset := b.fixedSize()

	tracer.Record(642677820169046180, tracer.ToScalar(offset))

	// Field (0) 'RandaoReveal'
	dst = append(dst, b.RandaoReveal[:]...)

	tracer.Record(10095149564870410566, tracer.ToScalar(dst))

	// Field (1) 'Eth1Data'
	if dst, err = b.Eth1Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Graffiti'
	dst = append(dst, b.Graffiti[:]...)

	tracer.Record(1938884375001766421, tracer.ToScalar(dst))

	// Offset (3) 'ProposerSlashings'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(1938884375001766421, tracer.ToScalar(dst))
	offset += len(b.ProposerSlashings) * 416

	tracer.Record(4853196169973298709, tracer.ToScalar(offset))

	// Offset (4) 'AttesterSlashings'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(1938884375001766421, tracer.ToScalar(dst))
	offset += len(b.AttesterSlashings) * 448

	tracer.Record(4853196169973298709, tracer.ToScalar(offset))

	// Offset (5) 'Attestations'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(1938884375001766421, tracer.ToScalar(dst))
	for ii := 0; ii < len(b.Attestations); ii++ {
		offset += 4
		tracer.Record(13475953998132066890, tracer.ToScalar(offset))
		offset += b.Attestations[ii].SizeSSZ()
		tracer.Record(13475953998132066890, tracer.ToScalar(offset))
	}

	// Offset (6) 'Deposits'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(14547142586060853660, tracer.ToScalar(dst))
	offset += len(b.Deposits) * 312

	tracer.Record(13475953998132066890, tracer.ToScalar(offset))

	// Offset (7) 'VoluntaryExits'
	dst = ssz.WriteOffset(dst, offset)

	tracer.Record(14547142586060853660, tracer.ToScalar(dst))

	// Field (3) 'ProposerSlashings'
	if size := uint64(len(b.ProposerSlashings)); size > 128 {
		err = ssz.ErrListTooBigFn("BlockBodyBench.ProposerSlashings", size, 128)
		tracer.Record(10266434601203767679, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(b.ProposerSlashings); ii++ {
		if dst, err = b.ProposerSlashings[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (4) 'AttesterSlashings'
	if size := uint64(len(b.AttesterSlashings)); size > 128 {
		err = ssz.ErrListTooBigFn("BlockBodyBench.AttesterSlashings", size, 128)
		tracer.Record(6650508201574559168, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(b.AttesterSlashings); ii++ {
		if dst, err = b.AttesterSlashings[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (5) 'Attestations'
	if size := uint64(len(b.Attestations)); size > 128 {
		err = ssz.ErrListTooBigFn("BlockBodyBench.Attestations", size, 128)
		tracer.Record(563298669793126836, tracer.ToScalar(err))
		return
	}
	{
		offset = 4 * len(b.Attestations)
		tracer.Record(13739423755396233149, tracer.ToScalar(offset))
		for ii := 0; ii < len(b.Attestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			tracer.Record(5675793487236665838, tracer.ToScalar(dst))
			offset += b.Attestations[ii].SizeSSZ()
			tracer.Record(16459642441902193932, tracer.ToScalar(offset))
		}
	}
	for ii := 0; ii < len(b.Attestations); ii++ {
		if dst, err = b.Attestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (6) 'Deposits'
	if size := uint64(len(b.Deposits)); size > 128 {
		err = ssz.ErrListTooBigFn("BlockBodyBench.Deposits", size, 128)
		tracer.Record(17898671604431444801, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(b.Deposits); ii++ {
		if dst, err = b.Deposits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (7) 'VoluntaryExits'
	if size := uint64(len(b.VoluntaryExits)); size > 128 {
		err = ssz.ErrListTooBigFn("BlockBodyBench.VoluntaryExits", size, 128)
		tracer.Record(697632316003661452, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(b.VoluntaryExits); ii++ {
		if dst, err = b.VoluntaryExits[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlockBodyBench object
func (b *BlockBodyBench) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BlockBodyBench object and returns the remaining bufferº
func (b *BlockBodyBench) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(5376844926049658418, tracer.ToScalar(size))
	fixedSize := b.fixedSize()
	tracer.Record(11095981526605957302, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	tracer.Record(1871508765119975144, tracer.ToScalar(tail))
	var o3, o4, o5, o6, o7 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	tracer.Record(10306528967774195020, tracer.ToScalar(marker))

	// Field (0) 'RandaoReveal'
	buf = ssz.UnmarshalFixedBytes(b.RandaoReveal[:], buf)

	tracer.Record(18418781642450680807, tracer.ToScalar(buf))

	// Field (1) 'Eth1Data'
	if buf, err = b.Eth1Data.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (2) 'Graffiti'
	buf = ssz.UnmarshalFixedBytes(b.Graffiti[:], buf)

	tracer.Record(10826477961641141902, tracer.ToScalar(buf))

	// Offset (3) 'ProposerSlashings'
	if o3, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (4) 'AttesterSlashings'
	if o4, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (5) 'Attestations'
	if o5, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (6) 'Deposits'
	if o6, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (7) 'VoluntaryExits'
	if o7, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (3) 'ProposerSlashings'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.ProposerSlashings, tail[o3:o4], 416, 128, func(ii uint64, buf []byte) (err error) {
		if buf, err = b.ProposerSlashings[ii].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (4) 'AttesterSlashings'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.AttesterSlashings, tail[o4:o5], 448, 128, func(ii uint64, buf []byte) (err error) {
		if buf, err = b.AttesterSlashings[ii].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (5) 'Attestations'
	if err = ssz.UnmarshalDynamicSliceWithCallback(&b.Attestations, tail[o5:o6], 128, func(indx uint64, buf []byte) (err error) {
		if buf, err = b.Attestations[indx].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (6) 'Deposits'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.Deposits, tail[o6:o7], 312, 128, func(ii uint64, buf []byte) (err error) {
		if buf, err = b.Deposits[ii].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (7) 'VoluntaryExits'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.VoluntaryExits, tail[o7:], 112, 128, func(ii uint64, buf []byte) (err error) {
		if buf, err = b.VoluntaryExits[ii].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BlockBodyBench object
func (b *BlockBodyBench) fixedSize() int {
	return int(220)
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockBodyBench object
func (b *BlockBodyBench) SizeSSZ() (size int) {
	size = b.fixedSize()

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (3) 'ProposerSlashings'
	size += len(b.ProposerSlashings) * 416

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (4) 'AttesterSlashings'
	size += len(b.AttesterSlashings) * 448

	tracer.Record(12478871526554291020, tracer.ToScalar(size))

	// Field (5) 'Attestations'
	for ii := 0; ii < len(b.Attestations); ii++ {
		size += 4
		tracer.Record(12311935605700098293, tracer.ToScalar(size))
		size += b.Attestations[ii].SizeSSZ()
		tracer.Record(12311935605700098293, tracer.ToScalar(size))
	}

	// Field (6) 'Deposits'
	size += len(b.Deposits) * 312

	tracer.Record(12311935605700098293, tracer.ToScalar(size))

	// Field (7) 'VoluntaryExits'
	size += len(b.VoluntaryExits) * 112

	tracer.Record(12311935605700098293, tracer.ToScalar(size))

	return
}

// HashTreeRoot ssz hashes the BlockBodyBench object
func (b *BlockBodyBench) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockBodyBench object with a hasher
func (b *BlockBodyBench) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(2562346997231854237, tracer.ToScalar(indx))

	// Field (0) 'RandaoReveal'
	hh.PutBytes(b.RandaoReveal[:])

	// Field (1) 'Eth1Data'
	if err = b.Eth1Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Graffiti'
	hh.PutBytes(b.Graffiti[:])

	// Field (3) 'ProposerSlashings'
	{
		subIndx := hh.Index()
		tracer.Record(2269996082009391177, tracer.ToScalar(subIndx))
		num := uint64(len(b.ProposerSlashings))
		tracer.Record(8847828617750882656, tracer.ToScalar(num))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(6884712433342093612, tracer.ToScalar(err))
			return
		}
		for _, elem := range b.ProposerSlashings {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (4) 'AttesterSlashings'
	{
		subIndx := hh.Index()
		tracer.Record(14775272623032717509, tracer.ToScalar(subIndx))
		num := uint64(len(b.AttesterSlashings))
		tracer.Record(15234495969990671276, tracer.ToScalar(num))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(14897504709158182664, tracer.ToScalar(err))
			return
		}
		for _, elem := range b.AttesterSlashings {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (5) 'Attestations'
	{
		subIndx := hh.Index()
		tracer.Record(14215596369132501442, tracer.ToScalar(subIndx))
		num := uint64(len(b.Attestations))
		tracer.Record(3487842397611938147, tracer.ToScalar(num))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(3259781592892722107, tracer.ToScalar(err))
			return
		}
		for _, elem := range b.Attestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (6) 'Deposits'
	{
		subIndx := hh.Index()
		tracer.Record(7814564950403441894, tracer.ToScalar(subIndx))
		num := uint64(len(b.Deposits))
		tracer.Record(13944883939693290311, tracer.ToScalar(num))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(5172518276827122031, tracer.ToScalar(err))
			return
		}
		for _, elem := range b.Deposits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	// Field (7) 'VoluntaryExits'
	{
		subIndx := hh.Index()
		tracer.Record(15605876009372345946, tracer.ToScalar(subIndx))
		num := uint64(len(b.VoluntaryExits))
		tracer.Record(2740456266655068043, tracer.ToScalar(num))
		if num > 128 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(13804482780934581792, tracer.ToScalar(err))
			return
		}
		for _, elem := range b.VoluntaryExits {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 128)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockBodyBench object
func (b *BlockBodyBench) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}
