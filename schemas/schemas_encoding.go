// Code generated by fastssz. DO NOT EDIT.
// Hash: f8977957c2a1a8778de88cb27998226138b9967a962b8a7793beea5f7ee8fd08
// Version: 2.0.0
package schemas

import (
	ssz "github.com/ferranbt/fastssz"
	"github.com/ferranbt/fastssz/tracer"
)

// MarshalSSZ ssz marshals the BitvectorStruct object
func (b *BitvectorStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitvectorStruct object to a target array
func (b *BitvectorStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'ValidationBits'
	dst = append(dst, b.ValidationBits[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitvectorStruct object
func (b *BitvectorStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitvectorStruct object and returns the remaining bufferº
func (b *BitvectorStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	// Field (0) 'ValidationBits'
	buf = ssz.UnmarshalFixedBytes(b.ValidationBits[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("ValidationBits"))), tracer.ToBytesValue(b.ValidationBits[:]))

	tracer.Record(777, tracer.ToScalar(len(buf)))
	return buf, nil
}

// fixedSize returns the fixed size of the BitvectorStruct object
func (b *BitvectorStruct) fixedSize() int {
	return int(1)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitvectorStruct object
func (b *BitvectorStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BitvectorStruct object
func (b *BitvectorStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitvectorStruct object with a hasher
func (b *BitvectorStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidationBits'
	hh.PutBytes(b.ValidationBits[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitvectorStruct object
func (b *BitvectorStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BooleanStruct object
func (b *BooleanStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BooleanStruct object to a target array
func (b *BooleanStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Val'
	dst = ssz.MarshalValue(dst, b.Val)

	return
}

// UnmarshalSSZ ssz unmarshals the BooleanStruct object
func (b *BooleanStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BooleanStruct object and returns the remaining bufferº
func (b *BooleanStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	// Field (0) 'Val'
	b.Val, buf = ssz.UnmarshallValue[bool](buf)
	tracer.Record(uint64(tracer.Hash([]byte("Val"))), tracer.ToScalar(b.Val))

	tracer.Record(777, tracer.ToScalar(len(buf)))
	return buf, nil
}

// fixedSize returns the fixed size of the BooleanStruct object
func (b *BooleanStruct) fixedSize() int {
	return int(1)
}

// SizeSSZ returns the ssz encoded size in bytes for the BooleanStruct object
func (b *BooleanStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BooleanStruct object
func (b *BooleanStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BooleanStruct object with a hasher
func (b *BooleanStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Val'
	hh.PutBool(b.Val)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BooleanStruct object
func (b *BooleanStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the GapStruct object
func (g *GapStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GapStruct object to a target array
func (g *GapStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := g.fixedSize()

	// Offset (0) 'Data'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Data'
	if size := uint64(len(g.Data)); size > 1024 {
		err = ssz.ErrBytesLengthFn("GapStruct.Data", size, 1024)
		return
	}
	dst = append(dst, g.Data...)

	return
}

// UnmarshalSSZ ssz unmarshals the GapStruct object
func (g *GapStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(g, buf)
}

// UnmarshalSSZTail unmarshals the GapStruct object and returns the remaining bufferº
func (g *GapStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := g.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	tail := buf
	var o0 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'Data'
	if o0, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (0) 'Data'
	if g.Data, err = ssz.UnmarshalDynamicBytes(g.Data, tail[o0:], 1024); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the GapStruct object
func (g *GapStruct) fixedSize() int {
	return int(4)
}

// SizeSSZ returns the ssz encoded size in bytes for the GapStruct object
func (g *GapStruct) SizeSSZ() (size int) {
	size = g.fixedSize()

	// Field (0) 'Data'
	size += len(g.Data)

	return
}

// HashTreeRoot ssz hashes the GapStruct object
func (g *GapStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GapStruct object with a hasher
func (g *GapStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Data'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.Data))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.Data)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GapStruct object
func (g *GapStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}

// MarshalSSZ ssz marshals the Fork object
func (f *Fork) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the Fork object to a target array
func (f *Fork) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'PreviousVersion'
	dst = append(dst, f.PreviousVersion[:]...)

	// Field (1) 'CurrentVersion'
	dst = append(dst, f.CurrentVersion[:]...)

	// Field (2) 'Epoch'
	dst = ssz.MarshalValue(dst, f.Epoch)

	return
}

// UnmarshalSSZ ssz unmarshals the Fork object
func (f *Fork) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(f, buf)
}

// UnmarshalSSZTail unmarshals the Fork object and returns the remaining bufferº
func (f *Fork) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := f.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	// Field (0) 'PreviousVersion'
	buf = ssz.UnmarshalFixedBytes(f.PreviousVersion[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("PreviousVersion"))), tracer.ToBytesValue(f.PreviousVersion[:]))

	// Field (1) 'CurrentVersion'
	buf = ssz.UnmarshalFixedBytes(f.CurrentVersion[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("CurrentVersion"))), tracer.ToBytesValue(f.CurrentVersion[:]))

	// Field (2) 'Epoch'
	f.Epoch, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("Epoch"))), tracer.ToScalar(f.Epoch))

	tracer.Record(777, tracer.ToScalar(len(buf)))
	return buf, nil
}

// fixedSize returns the fixed size of the Fork object
func (f *Fork) fixedSize() int {
	return int(16)
}

// SizeSSZ returns the ssz encoded size in bytes for the Fork object
func (f *Fork) SizeSSZ() (size int) {
	size = f.fixedSize()
	return
}

// HashTreeRoot ssz hashes the Fork object
func (f *Fork) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the Fork object with a hasher
func (f *Fork) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'PreviousVersion'
	hh.PutBytes(f.PreviousVersion[:])

	// Field (1) 'CurrentVersion'
	hh.PutBytes(f.CurrentVersion[:])

	// Field (2) 'Epoch'
	hh.PutUint64(f.Epoch)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Fork object
func (f *Fork) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(f)
}

// MarshalSSZ ssz marshals the BeaconBlockHeader object
func (b *BeaconBlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconBlockHeader object to a target array
func (b *BeaconBlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalValue(dst, uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	// Field (3) 'StateRoot'
	dst = append(dst, b.StateRoot[:]...)

	// Field (4) 'BodyRoot'
	dst = append(dst, b.BodyRoot[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconBlockHeader object
func (b *BeaconBlockHeader) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BeaconBlockHeader object and returns the remaining bufferº
func (b *BeaconBlockHeader) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	// Field (0) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.Slot = Slot(val)
		tracer.Record(uint64(tracer.Hash([]byte("Slot"))), tracer.ToScalar(val))
	}

	// Field (1) 'ProposerIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.ProposerIndex = ValidatorIndex(val)
		tracer.Record(uint64(tracer.Hash([]byte("ProposerIndex"))), tracer.ToScalar(val))
	}

	// Field (2) 'ParentRoot'
	buf = ssz.UnmarshalFixedBytes(b.ParentRoot[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("ParentRoot"))), tracer.ToBytesValue(b.ParentRoot[:]))

	// Field (3) 'StateRoot'
	buf = ssz.UnmarshalFixedBytes(b.StateRoot[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("StateRoot"))), tracer.ToBytesValue(b.StateRoot[:]))

	// Field (4) 'BodyRoot'
	buf = ssz.UnmarshalFixedBytes(b.BodyRoot[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("BodyRoot"))), tracer.ToBytesValue(b.BodyRoot[:]))

	tracer.Record(777, tracer.ToScalar(len(buf)))
	return buf, nil
}

// fixedSize returns the fixed size of the BeaconBlockHeader object
func (b *BeaconBlockHeader) fixedSize() int {
	return int(112)
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconBlockHeader object
func (b *BeaconBlockHeader) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BeaconBlockHeader object
func (b *BeaconBlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconBlockHeader object with a hasher
func (b *BeaconBlockHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(uint64(b.ProposerIndex))

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'StateRoot'
	hh.PutBytes(b.StateRoot[:])

	// Field (4) 'BodyRoot'
	hh.PutBytes(b.BodyRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconBlockHeader object
func (b *BeaconBlockHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the Eth1Data object
func (e *Eth1Data) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(e)
}

// MarshalSSZTo ssz marshals the Eth1Data object to a target array
func (e *Eth1Data) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'DepositRoot'
	dst = append(dst, e.DepositRoot[:]...)

	// Field (1) 'DepositCount'
	dst = ssz.MarshalValue(dst, e.DepositCount)

	// Field (2) 'BlockHash'
	dst = append(dst, e.BlockHash[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the Eth1Data object
func (e *Eth1Data) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(e, buf)
}

// UnmarshalSSZTail unmarshals the Eth1Data object and returns the remaining bufferº
func (e *Eth1Data) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := e.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	// Field (0) 'DepositRoot'
	buf = ssz.UnmarshalFixedBytes(e.DepositRoot[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("DepositRoot"))), tracer.ToBytesValue(e.DepositRoot[:]))

	// Field (1) 'DepositCount'
	e.DepositCount, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("DepositCount"))), tracer.ToScalar(e.DepositCount))

	// Field (2) 'BlockHash'
	buf = ssz.UnmarshalFixedBytes(e.BlockHash[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("BlockHash"))), tracer.ToBytesValue(e.BlockHash[:]))

	tracer.Record(777, tracer.ToScalar(len(buf)))
	return buf, nil
}

// fixedSize returns the fixed size of the Eth1Data object
func (e *Eth1Data) fixedSize() int {
	return int(72)
}

// SizeSSZ returns the ssz encoded size in bytes for the Eth1Data object
func (e *Eth1Data) SizeSSZ() (size int) {
	size = e.fixedSize()
	return
}

// HashTreeRoot ssz hashes the Eth1Data object
func (e *Eth1Data) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(e)
}

// HashTreeRootWith ssz hashes the Eth1Data object with a hasher
func (e *Eth1Data) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'DepositRoot'
	hh.PutBytes(e.DepositRoot[:])

	// Field (1) 'DepositCount'
	hh.PutUint64(e.DepositCount)

	// Field (2) 'BlockHash'
	hh.PutBytes(e.BlockHash[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Eth1Data object
func (e *Eth1Data) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(e)
}

// MarshalSSZ ssz marshals the Checkpoint object
func (c *Checkpoint) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Checkpoint object to a target array
func (c *Checkpoint) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Epoch'
	dst = ssz.MarshalValue(dst, c.Epoch)

	// Field (1) 'Root'
	dst = append(dst, c.Root[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the Checkpoint object
func (c *Checkpoint) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(c, buf)
}

// UnmarshalSSZTail unmarshals the Checkpoint object and returns the remaining bufferº
func (c *Checkpoint) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := c.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	// Field (0) 'Epoch'
	c.Epoch, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("Epoch"))), tracer.ToScalar(c.Epoch))

	// Field (1) 'Root'
	buf = ssz.UnmarshalFixedBytes(c.Root[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("Root"))), tracer.ToBytesValue(c.Root[:]))

	tracer.Record(777, tracer.ToScalar(len(buf)))
	return buf, nil
}

// fixedSize returns the fixed size of the Checkpoint object
func (c *Checkpoint) fixedSize() int {
	return int(40)
}

// SizeSSZ returns the ssz encoded size in bytes for the Checkpoint object
func (c *Checkpoint) SizeSSZ() (size int) {
	size = c.fixedSize()
	return
}

// HashTreeRoot ssz hashes the Checkpoint object
func (c *Checkpoint) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Checkpoint object with a hasher
func (c *Checkpoint) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Epoch'
	hh.PutUint64(c.Epoch)

	// Field (1) 'Root'
	hh.PutBytes(c.Root[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Checkpoint object
func (c *Checkpoint) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the Validator object
func (v *Validator) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the Validator object to a target array
func (v *Validator) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Pubkey'
	dst = append(dst, v.Pubkey[:]...)

	// Field (1) 'WithdrawalCredentials'
	dst = append(dst, v.WithdrawalCredentials[:]...)

	// Field (2) 'EffectiveBalance'
	dst = ssz.MarshalValue(dst, uint64(v.EffectiveBalance))

	// Field (3) 'Slashed'
	dst = ssz.MarshalValue(dst, v.Slashed)

	// Field (4) 'ActivationEligibilityEpoch'
	dst = ssz.MarshalValue(dst, v.ActivationEligibilityEpoch)

	// Field (5) 'ActivationEpoch'
	dst = ssz.MarshalValue(dst, v.ActivationEpoch)

	// Field (6) 'ExitEpoch'
	dst = ssz.MarshalValue(dst, v.ExitEpoch)

	// Field (7) 'WithdrawableEpoch'
	dst = ssz.MarshalValue(dst, v.WithdrawableEpoch)

	return
}

// UnmarshalSSZ ssz unmarshals the Validator object
func (v *Validator) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(v, buf)
}

// UnmarshalSSZTail unmarshals the Validator object and returns the remaining bufferº
func (v *Validator) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := v.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	// Field (0) 'Pubkey'
	buf = ssz.UnmarshalFixedBytes(v.Pubkey[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("Pubkey"))), tracer.ToBytesValue(v.Pubkey[:]))

	// Field (1) 'WithdrawalCredentials'
	buf = ssz.UnmarshalFixedBytes(v.WithdrawalCredentials[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("WithdrawalCredentials"))), tracer.ToBytesValue(v.WithdrawalCredentials[:]))

	// Field (2) 'EffectiveBalance'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		v.EffectiveBalance = Gwei(val)
		tracer.Record(uint64(tracer.Hash([]byte("EffectiveBalance"))), tracer.ToScalar(val))
	}

	// Field (3) 'Slashed'
	v.Slashed, buf = ssz.UnmarshallValue[bool](buf)
	tracer.Record(uint64(tracer.Hash([]byte("Slashed"))), tracer.ToScalar(v.Slashed))

	// Field (4) 'ActivationEligibilityEpoch'
	v.ActivationEligibilityEpoch, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("ActivationEligibilityEpoch"))), tracer.ToScalar(v.ActivationEligibilityEpoch))

	// Field (5) 'ActivationEpoch'
	v.ActivationEpoch, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("ActivationEpoch"))), tracer.ToScalar(v.ActivationEpoch))

	// Field (6) 'ExitEpoch'
	v.ExitEpoch, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("ExitEpoch"))), tracer.ToScalar(v.ExitEpoch))

	// Field (7) 'WithdrawableEpoch'
	v.WithdrawableEpoch, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("WithdrawableEpoch"))), tracer.ToScalar(v.WithdrawableEpoch))

	tracer.Record(777, tracer.ToScalar(len(buf)))
	return buf, nil
}

// fixedSize returns the fixed size of the Validator object
func (v *Validator) fixedSize() int {
	return int(121)
}

// SizeSSZ returns the ssz encoded size in bytes for the Validator object
func (v *Validator) SizeSSZ() (size int) {
	size = v.fixedSize()
	return
}

// HashTreeRoot ssz hashes the Validator object
func (v *Validator) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the Validator object with a hasher
func (v *Validator) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Pubkey'
	hh.PutBytes(v.Pubkey[:])

	// Field (1) 'WithdrawalCredentials'
	hh.PutBytes(v.WithdrawalCredentials[:])

	// Field (2) 'EffectiveBalance'
	hh.PutUint64(uint64(v.EffectiveBalance))

	// Field (3) 'Slashed'
	hh.PutBool(v.Slashed)

	// Field (4) 'ActivationEligibilityEpoch'
	hh.PutUint64(v.ActivationEligibilityEpoch)

	// Field (5) 'ActivationEpoch'
	hh.PutUint64(v.ActivationEpoch)

	// Field (6) 'ExitEpoch'
	hh.PutUint64(v.ExitEpoch)

	// Field (7) 'WithdrawableEpoch'
	hh.PutUint64(v.WithdrawableEpoch)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Validator object
func (v *Validator) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the AttestationData object
func (a *AttestationData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttestationData object to a target array
func (a *AttestationData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(a.Slot))

	// Field (1) 'Index'
	dst = ssz.MarshalValue(dst, a.Index)

	// Field (2) 'BeaconBlockRoot'
	dst = append(dst, a.BeaconBlockRoot[:]...)

	// Field (3) 'Source'
	if dst, err = a.Source.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'Target'
	if dst, err = a.Target.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AttestationData object
func (a *AttestationData) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(a, buf)
}

// UnmarshalSSZTail unmarshals the AttestationData object and returns the remaining bufferº
func (a *AttestationData) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := a.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	// Field (0) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		a.Slot = Slot(val)
		tracer.Record(uint64(tracer.Hash([]byte("Slot"))), tracer.ToScalar(val))
	}

	// Field (1) 'Index'
	a.Index, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("Index"))), tracer.ToScalar(a.Index))

	// Field (2) 'BeaconBlockRoot'
	buf = ssz.UnmarshalFixedBytes(a.BeaconBlockRoot[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("BeaconBlockRoot"))), tracer.ToBytesValue(a.BeaconBlockRoot[:]))

	// Field (3) 'Source'
	if buf, err = a.Source.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (4) 'Target'
	if buf, err = a.Target.UnmarshalSSZTail(buf); err != nil {
		return
	}

	tracer.Record(777, tracer.ToScalar(len(buf)))
	return buf, nil
}

// fixedSize returns the fixed size of the AttestationData object
func (a *AttestationData) fixedSize() int {
	return int(128)
}

// SizeSSZ returns the ssz encoded size in bytes for the AttestationData object
func (a *AttestationData) SizeSSZ() (size int) {
	size = a.fixedSize()
	return
}

// HashTreeRoot ssz hashes the AttestationData object
func (a *AttestationData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttestationData object with a hasher
func (a *AttestationData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(a.Slot))

	// Field (1) 'Index'
	hh.PutUint64(a.Index)

	// Field (2) 'BeaconBlockRoot'
	hh.PutBytes(a.BeaconBlockRoot[:])

	// Field (3) 'Source'
	if err = a.Source.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'Target'
	if err = a.Target.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AttestationData object
func (a *AttestationData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the PendingAttestation object
func (p *PendingAttestation) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the PendingAttestation object to a target array
func (p *PendingAttestation) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := p.fixedSize()

	// Offset (0) 'AggregationBits'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'Data'
	if dst, err = p.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'InclusionDelay'
	dst = ssz.MarshalValue(dst, uint64(p.InclusionDelay))

	// Field (3) 'ProposerIndex'
	dst = ssz.MarshalValue(dst, uint64(p.ProposerIndex))

	// Field (0) 'AggregationBits'
	if size := uint64(len(p.AggregationBits)); size > 2048 {
		err = ssz.ErrBytesLengthFn("PendingAttestation.AggregationBits", size, 2048)
		return
	}
	dst = append(dst, p.AggregationBits...)

	return
}

// UnmarshalSSZ ssz unmarshals the PendingAttestation object
func (p *PendingAttestation) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(p, buf)
}

// UnmarshalSSZTail unmarshals the PendingAttestation object and returns the remaining bufferº
func (p *PendingAttestation) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := p.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	tail := buf
	var o0 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'AggregationBits'
	if o0, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'Data'
	if buf, err = p.Data.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (2) 'InclusionDelay'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		p.InclusionDelay = Slot(val)
		tracer.Record(uint64(tracer.Hash([]byte("InclusionDelay"))), tracer.ToScalar(val))
	}

	// Field (3) 'ProposerIndex'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		p.ProposerIndex = ValidatorIndex(val)
		tracer.Record(uint64(tracer.Hash([]byte("ProposerIndex"))), tracer.ToScalar(val))
	}

	// Field (0) 'AggregationBits'
	if p.AggregationBits, err = ssz.UnmarshalDynamicBytes(p.AggregationBits, tail[o0:], 2048); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the PendingAttestation object
func (p *PendingAttestation) fixedSize() int {
	return int(148)
}

// SizeSSZ returns the ssz encoded size in bytes for the PendingAttestation object
func (p *PendingAttestation) SizeSSZ() (size int) {
	size = p.fixedSize()

	// Field (0) 'AggregationBits'
	size += len(p.AggregationBits)

	return
}

// HashTreeRoot ssz hashes the PendingAttestation object
func (p *PendingAttestation) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the PendingAttestation object with a hasher
func (p *PendingAttestation) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'AggregationBits'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(p.AggregationBits))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(p.AggregationBits)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	// Field (1) 'Data'
	if err = p.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'InclusionDelay'
	hh.PutUint64(uint64(p.InclusionDelay))

	// Field (3) 'ProposerIndex'
	hh.PutUint64(uint64(p.ProposerIndex))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the PendingAttestation object
func (p *PendingAttestation) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the BeaconState object
func (b *BeaconState) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BeaconState object to a target array
func (b *BeaconState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Field (0) 'GenesisTime'
	dst = ssz.MarshalValue(dst, b.GenesisTime)

	// Field (1) 'GenesisValidatorsRoot'
	dst = append(dst, b.GenesisValidatorsRoot[:]...)

	// Field (2) 'Slot'
	dst = ssz.MarshalValue(dst, uint64(b.Slot))

	// Field (3) 'Fork'
	if dst, err = b.Fork.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'LatestBlockHeader'
	if dst, err = b.LatestBlockHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (5) 'BlockRoots'
	if size := uint64(len(b.BlockRoots)); size != 4 {
		err = ssz.ErrVectorLengthFn("BeaconState.BlockRoots", size, 4)
		return
	}
	for ii := uint64(0); ii < 4; ii++ {
		dst = append(dst, b.BlockRoots[ii][:]...)
	}

	// Field (6) 'StateRoots'
	if size := uint64(len(b.StateRoots)); size != 4 {
		err = ssz.ErrVectorLengthFn("BeaconState.StateRoots", size, 4)
		return
	}
	for ii := uint64(0); ii < 4; ii++ {
		dst = append(dst, b.StateRoots[ii][:]...)
	}

	// Offset (7) 'HistoricalRoots'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.HistoricalRoots) * 32

	// Field (8) 'Eth1Data'
	if dst, err = b.Eth1Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (9) 'Eth1DataVotes'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Eth1DataVotes) * 72

	// Field (10) 'Eth1DepositIndex'
	dst = ssz.MarshalValue(dst, b.Eth1DepositIndex)

	// Offset (11) 'Validators'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Validators) * 121

	// Offset (12) 'Balances'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Balances) * 8

	// Field (13) 'RandaoMixes'
	if size := uint64(len(b.RandaoMixes)); size != 4 {
		err = ssz.ErrVectorLengthFn("BeaconState.RandaoMixes", size, 4)
		return
	}
	for ii := uint64(0); ii < 4; ii++ {
		dst = append(dst, b.RandaoMixes[ii][:]...)
	}

	// Field (14) 'Slashings'
	if size := uint64(len(b.Slashings)); size != 4 {
		err = ssz.ErrVectorLengthFn("BeaconState.Slashings", size, 4)
		return
	}
	for ii := uint64(0); ii < 4; ii++ {
		dst = ssz.MarshalValue(dst, uint64(b.Slashings[ii]))
	}

	// Offset (15) 'PreviousEpochAttestations'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.PreviousEpochAttestations); ii++ {
		offset += 4
		offset += b.PreviousEpochAttestations[ii].SizeSSZ()
	}

	// Offset (16) 'CurrentEpochAttestations'
	dst = ssz.WriteOffset(dst, offset)

	// Field (17) 'JustificationBits'
	// Clean padding bits to produce canonical output
	cleaned := b.JustificationBits[0] & 0x0F
	dst = append(dst, cleaned)

	// Field (18) 'PreviousJustifiedCheckpoint'
	if dst, err = b.PreviousJustifiedCheckpoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (19) 'CurrentJustifiedCheckpoint'
	if dst, err = b.CurrentJustifiedCheckpoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (20) 'FinalizedCheckpoint'
	if dst, err = b.FinalizedCheckpoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (7) 'HistoricalRoots'
	if size := uint64(len(b.HistoricalRoots)); size > 4 {
		err = ssz.ErrListTooBigFn("BeaconState.HistoricalRoots", size, 4)
		return
	}
	for ii := 0; ii < len(b.HistoricalRoots); ii++ {
		dst = append(dst, b.HistoricalRoots[ii][:]...)
	}

	// Field (9) 'Eth1DataVotes'
	if size := uint64(len(b.Eth1DataVotes)); size > 4 {
		err = ssz.ErrListTooBigFn("BeaconState.Eth1DataVotes", size, 4)
		return
	}
	for ii := 0; ii < len(b.Eth1DataVotes); ii++ {
		if dst, err = b.Eth1DataVotes[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (11) 'Validators'
	if size := uint64(len(b.Validators)); size > 4 {
		err = ssz.ErrListTooBigFn("BeaconState.Validators", size, 4)
		return
	}
	for ii := 0; ii < len(b.Validators); ii++ {
		if dst, err = b.Validators[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (12) 'Balances'
	if size := uint64(len(b.Balances)); size > 4 {
		err = ssz.ErrListTooBigFn("BeaconState.Balances", size, 4)
		return
	}
	for ii := 0; ii < len(b.Balances); ii++ {
		dst = ssz.MarshalValue(dst, uint64(b.Balances[ii]))
	}

	// Field (15) 'PreviousEpochAttestations'
	if size := uint64(len(b.PreviousEpochAttestations)); size > 4 {
		err = ssz.ErrListTooBigFn("BeaconState.PreviousEpochAttestations", size, 4)
		return
	}
	{
		offset = 4 * len(b.PreviousEpochAttestations)
		for ii := 0; ii < len(b.PreviousEpochAttestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.PreviousEpochAttestations[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.PreviousEpochAttestations); ii++ {
		if dst, err = b.PreviousEpochAttestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (16) 'CurrentEpochAttestations'
	if size := uint64(len(b.CurrentEpochAttestations)); size > 4 {
		err = ssz.ErrListTooBigFn("BeaconState.CurrentEpochAttestations", size, 4)
		return
	}
	{
		offset = 4 * len(b.CurrentEpochAttestations)
		for ii := 0; ii < len(b.CurrentEpochAttestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.CurrentEpochAttestations[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.CurrentEpochAttestations); ii++ {
		if dst, err = b.CurrentEpochAttestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BeaconState object
func (b *BeaconState) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BeaconState object and returns the remaining bufferº
func (b *BeaconState) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(999, tracer.ToScalar(size)) // Trace 1: Input size
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}
	tracer.Record(888, tracer.ToScalar(fixedSize)) // Trace 2: Fixed size

	tail := buf
	var o7, o9, o11, o12, o15, o16 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'GenesisTime'
	b.GenesisTime, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("GenesisTime"))), tracer.ToScalar(b.GenesisTime))

	// Field (1) 'GenesisValidatorsRoot'
	buf = ssz.UnmarshalFixedBytes(b.GenesisValidatorsRoot[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("GenesisValidatorsRoot"))), tracer.ToBytesValue(b.GenesisValidatorsRoot[:]))

	// Field (2) 'Slot'
	{
		var val uint64
		val, buf = ssz.UnmarshallValue[uint64](buf)
		b.Slot = Slot(val)
		tracer.Record(uint64(tracer.Hash([]byte("Slot"))), tracer.ToScalar(val))
	}

	// Field (3) 'Fork'
	if buf, err = b.Fork.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (4) 'LatestBlockHeader'
	if buf, err = b.LatestBlockHeader.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (5) 'BlockRoots'
	b.BlockRoots = make([][32]byte, 4)
	for ii := uint64(0); ii < 4; ii++ {
		buf = ssz.UnmarshalFixedBytes(b.BlockRoots[ii][:], buf)
		tracer.Record(uint64(tracer.Hash([]byte("BlockRoots[ii]"))), tracer.ToBytesValue(b.BlockRoots[ii][:]))
	}

	// Field (6) 'StateRoots'
	b.StateRoots = make([][32]byte, 4)
	for ii := uint64(0); ii < 4; ii++ {
		buf = ssz.UnmarshalFixedBytes(b.StateRoots[ii][:], buf)
		tracer.Record(uint64(tracer.Hash([]byte("StateRoots[ii]"))), tracer.ToBytesValue(b.StateRoots[ii][:]))
	}

	// Offset (7) 'HistoricalRoots'
	if o7, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (8) 'Eth1Data'
	if buf, err = b.Eth1Data.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Offset (9) 'Eth1DataVotes'
	if o9, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (10) 'Eth1DepositIndex'
	b.Eth1DepositIndex, buf = ssz.UnmarshallValue[uint64](buf)
	tracer.Record(uint64(tracer.Hash([]byte("Eth1DepositIndex"))), tracer.ToScalar(b.Eth1DepositIndex))

	// Offset (11) 'Validators'
	if o11, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (12) 'Balances'
	if o12, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (13) 'RandaoMixes'
	b.RandaoMixes = make([][32]byte, 4)
	for ii := uint64(0); ii < 4; ii++ {
		buf = ssz.UnmarshalFixedBytes(b.RandaoMixes[ii][:], buf)
		tracer.Record(uint64(tracer.Hash([]byte("RandaoMixes[ii]"))), tracer.ToBytesValue(b.RandaoMixes[ii][:]))
	}

	// Field (14) 'Slashings'
	b.Slashings = ssz.Extend(b.Slashings, 4)
	for ii := uint64(0); ii < 4; ii++ {
		{
			var val uint64
			val, buf = ssz.UnmarshallValue[uint64](buf)
			b.Slashings[ii] = Gwei(val)
			tracer.Record(uint64(tracer.Hash([]byte("Slashings[ii]"))), tracer.ToScalar(val))
		}
	}

	// Offset (15) 'PreviousEpochAttestations'
	if o15, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (16) 'CurrentEpochAttestations'
	if o16, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (17) 'JustificationBits'
	buf = ssz.UnmarshalFixedBytes(b.JustificationBits[:], buf)
	tracer.Record(uint64(tracer.Hash([]byte("JustificationBits"))), tracer.ToBytesValue(b.JustificationBits[:]))

	// Field (18) 'PreviousJustifiedCheckpoint'
	if buf, err = b.PreviousJustifiedCheckpoint.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (19) 'CurrentJustifiedCheckpoint'
	if buf, err = b.CurrentJustifiedCheckpoint.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (20) 'FinalizedCheckpoint'
	if buf, err = b.FinalizedCheckpoint.UnmarshalSSZTail(buf); err != nil {
		return
	}

	// Field (7) 'HistoricalRoots'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.HistoricalRoots, tail[o7:o9], 32, 4, func(ii uint64, buf []byte) (err error) {
		buf = ssz.UnmarshalFixedBytes(b.HistoricalRoots[ii][:], buf)
		tracer.Record(uint64(tracer.Hash([]byte("HistoricalRoots[ii]"))), tracer.ToBytesValue(b.HistoricalRoots[ii][:]))
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (9) 'Eth1DataVotes'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.Eth1DataVotes, tail[o9:o11], 72, 4, func(ii uint64, buf []byte) (err error) {
		if buf, err = b.Eth1DataVotes[ii].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (11) 'Validators'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.Validators, tail[o11:o12], 121, 4, func(ii uint64, buf []byte) (err error) {
		if buf, err = b.Validators[ii].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (12) 'Balances'
	if err = ssz.UnmarshalSliceWithIndexCallback(&b.Balances, tail[o12:o15], 8, 4, func(ii uint64, buf []byte) (err error) {
		{
			var val uint64
			val, buf = ssz.UnmarshallValue[uint64](buf)
			b.Balances[ii] = Gwei(val)
			tracer.Record(uint64(tracer.Hash([]byte("Balances[ii]"))), tracer.ToScalar(val))
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (15) 'PreviousEpochAttestations'
	if err = ssz.UnmarshalDynamicSliceWithCallback(&b.PreviousEpochAttestations, tail[o15:o16], 4, func(indx uint64, buf []byte) (err error) {
		if buf, err = b.PreviousEpochAttestations[indx].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (16) 'CurrentEpochAttestations'
	if err = ssz.UnmarshalDynamicSliceWithCallback(&b.CurrentEpochAttestations, tail[o16:], 4, func(indx uint64, buf []byte) (err error) {
		if buf, err = b.CurrentEpochAttestations[indx].UnmarshalSSZTail(buf); err != nil {
			return
		}
		return nil
	}); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BeaconState object
func (b *BeaconState) fixedSize() int {
	return int(817)
}

// SizeSSZ returns the ssz encoded size in bytes for the BeaconState object
func (b *BeaconState) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (7) 'HistoricalRoots'
	size += len(b.HistoricalRoots) * 32

	// Field (9) 'Eth1DataVotes'
	size += len(b.Eth1DataVotes) * 72

	// Field (11) 'Validators'
	size += len(b.Validators) * 121

	// Field (12) 'Balances'
	size += len(b.Balances) * 8

	// Field (15) 'PreviousEpochAttestations'
	for ii := 0; ii < len(b.PreviousEpochAttestations); ii++ {
		size += 4
		size += b.PreviousEpochAttestations[ii].SizeSSZ()
	}

	// Field (16) 'CurrentEpochAttestations'
	for ii := 0; ii < len(b.CurrentEpochAttestations); ii++ {
		size += 4
		size += b.CurrentEpochAttestations[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the BeaconState object
func (b *BeaconState) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BeaconState object with a hasher
func (b *BeaconState) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'GenesisTime'
	hh.PutUint64(b.GenesisTime)

	// Field (1) 'GenesisValidatorsRoot'
	hh.PutBytes(b.GenesisValidatorsRoot[:])

	// Field (2) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (3) 'Fork'
	if err = b.Fork.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'LatestBlockHeader'
	if err = b.LatestBlockHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (5) 'BlockRoots'
	{
		if size := uint64(len(b.BlockRoots)); size != 4 {
			err = ssz.ErrVectorLengthFn("BeaconState.BlockRoots", size, 4)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.BlockRoots {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (6) 'StateRoots'
	{
		if size := uint64(len(b.StateRoots)); size != 4 {
			err = ssz.ErrVectorLengthFn("BeaconState.StateRoots", size, 4)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.StateRoots {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (7) 'HistoricalRoots'
	{
		if size := uint64(len(b.HistoricalRoots)); size > 4 {
			err = ssz.ErrListTooBigFn("BeaconState.HistoricalRoots", size, 4)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.HistoricalRoots {
			hh.Append(i[:])
		}
		numItems := uint64(len(b.HistoricalRoots))
		hh.MerkleizeWithMixin(subIndx, numItems, 4)
	}

	// Field (8) 'Eth1Data'
	if err = b.Eth1Data.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (9) 'Eth1DataVotes'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Eth1DataVotes))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Eth1DataVotes {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (10) 'Eth1DepositIndex'
	hh.PutUint64(b.Eth1DepositIndex)

	// Field (11) 'Validators'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Validators))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Validators {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (12) 'Balances'
	{
		if size := uint64(len(b.Balances)); size > 4 {
			err = ssz.ErrListTooBigFn("BeaconState.Balances", size, 4)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.Balances {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(b.Balances))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(4, numItems, 8))
	}

	// Field (13) 'RandaoMixes'
	{
		if size := uint64(len(b.RandaoMixes)); size != 4 {
			err = ssz.ErrVectorLengthFn("BeaconState.RandaoMixes", size, 4)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.RandaoMixes {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (14) 'Slashings'
	{
		if size := uint64(len(b.Slashings)); size != 4 {
			err = ssz.ErrVectorLengthFn("BeaconState.Slashings", size, 4)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.Slashings {
			hh.AppendUint64(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (15) 'PreviousEpochAttestations'
	{
		subIndx := hh.Index()
		num := uint64(len(b.PreviousEpochAttestations))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.PreviousEpochAttestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (16) 'CurrentEpochAttestations'
	{
		subIndx := hh.Index()
		num := uint64(len(b.CurrentEpochAttestations))
		if num > 4 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.CurrentEpochAttestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4)
	}

	// Field (17) 'JustificationBits'
	hh.PutBytes(b.JustificationBits[:])

	// Field (18) 'PreviousJustifiedCheckpoint'
	if err = b.PreviousJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (19) 'CurrentJustifiedCheckpoint'
	if err = b.CurrentJustifiedCheckpoint.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (20) 'FinalizedCheckpoint'
	if err = b.FinalizedCheckpoint.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BeaconState object
func (b *BeaconState) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}
