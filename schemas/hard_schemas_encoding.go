// Code generated by fastssz. DO NOT EDIT.
// Hash: f8977957c2a1a8778de88cb27998226138b9967a962b8a7793beea5f7ee8fd08
// Version: 2.0.0
package schemas

import "github.com/ferranbt/fastssz/tracer"

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the HardBitvectorStruct object
func (h *HardBitvectorStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(h)
}

// MarshalSSZTo ssz marshals the HardBitvectorStruct object to a target array
func (h *HardBitvectorStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset := h.fixedSize()

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, h.Magic)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (1) 'Padding'
	dst = append(dst, h.Padding[:]...)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (2) 'F0'
	dst = ssz.MarshalValue(dst, h.F0)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Offset (3) 'F1'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset += len(h.F1)

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Offset (4) 'F2'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset += h.F2.SizeSSZ()

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Offset (5) 'F3'
	dst = ssz.WriteOffset(dst, offset)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (6) 'Target'
	dst = append(dst, h.Target[:]...)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (3) 'F1'
	if size := uint64(len(h.F1)); size > 2048 {
		err = ssz.ErrBytesLengthFn("HardBitvectorStruct.F1", size, 2048)
		tracer.Record(13792041702645271617, tracer.ToScalar(err))
		return
	}
	dst = append(dst, h.F1...)

	tracer.Record(13287582469228152809, tracer.ToScalar(dst))

	// Field (4) 'F2'
	if dst, err = h.F2.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (5) 'F3'
	if size := uint64(len(h.F3)); size > 2048 {
		err = ssz.ErrBytesLengthFn("HardBitvectorStruct.F3", size, 2048)
		tracer.Record(41879210796514867, tracer.ToScalar(err))
		return
	}
	dst = append(dst, h.F3...)

	tracer.Record(17961113889319673671, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the HardBitvectorStruct object
func (h *HardBitvectorStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(h, buf)
}

// UnmarshalSSZTail unmarshals the HardBitvectorStruct object and returns the remaining bufferº
func (h *HardBitvectorStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(8402617314992080774, tracer.ToScalar(size))
	fixedSize := h.fixedSize()
	tracer.Record(194556321646530282, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	tracer.Record(8400561470327127284, tracer.ToScalar(tail))
	var o3, o4, o5 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	tracer.Record(13759569719659226616, tracer.ToScalar(marker))

	// Field (0) 'Magic'
	h.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(16046195392382727211, tracer.ToScalar(buf))

	// Field (1) 'Padding'
	buf = ssz.UnmarshalFixedBytes(h.Padding[:], buf)

	tracer.Record(16046195392382727211, tracer.ToScalar(buf))

	// Field (2) 'F0'
	h.F0, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(16046195392382727211, tracer.ToScalar(buf))

	// Offset (3) 'F1'
	if o3, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (4) 'F2'
	if o4, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (5) 'F3'
	if o5, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (6) 'Target'
	buf = ssz.UnmarshalFixedBytes(h.Target[:], buf)

	tracer.Record(13654044939386056828, tracer.ToScalar(buf))

	// Field (3) 'F1'
	if h.F1, err = ssz.UnmarshalDynamicBytes(h.F1, tail[o3:o4], 2048); err != nil {
		return
	}

	// Field (4) 'F2'
	if err = h.F2.UnmarshalSSZ(buf); err != nil {
		return
	}

	// Field (5) 'F3'
	if h.F3, err = ssz.UnmarshalDynamicBytes(h.F3, tail[o5:], 2048); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the HardBitvectorStruct object
func (h *HardBitvectorStruct) fixedSize() int {
	return int(4125)
}

// SizeSSZ returns the ssz encoded size in bytes for the HardBitvectorStruct object
func (h *HardBitvectorStruct) SizeSSZ() (size int) {
	size = h.fixedSize()

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (3) 'F1'
	size += len(h.F1)

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (4) 'F2'
	size += h.F2.SizeSSZ()

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (5) 'F3'
	size += len(h.F3)

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	return
}

// HashTreeRoot ssz hashes the HardBitvectorStruct object
func (h *HardBitvectorStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(h)
}

// HashTreeRootWith ssz hashes the HardBitvectorStruct object with a hasher
func (h *HardBitvectorStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(9124548103629576633, tracer.ToScalar(indx))

	// Field (0) 'Magic'
	hh.PutUint64(h.Magic)

	// Field (1) 'Padding'
	hh.PutBytes(h.Padding[:])

	// Field (2) 'F0'
	hh.PutUint64(h.F0)

	// Field (3) 'F1'
	{
		elemIndx := hh.Index()
		tracer.Record(17405718152972083287, tracer.ToScalar(elemIndx))
		byteLen := uint64(len(h.F1))
		tracer.Record(14665136328895629076, tracer.ToScalar(byteLen))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(1756680335971179755, tracer.ToScalar(err))
			return
		}
		hh.Append(h.F1)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	// Field (4) 'F2'
	if err = h.F2.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (5) 'F3'
	{
		elemIndx := hh.Index()
		tracer.Record(2942837163400678198, tracer.ToScalar(elemIndx))
		byteLen := uint64(len(h.F3))
		tracer.Record(12068525842657807363, tracer.ToScalar(byteLen))
		if byteLen > 2048 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(10864966389090187078, tracer.ToScalar(err))
			return
		}
		hh.Append(h.F3)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (2048+31)/32)
	}

	// Field (6) 'Target'
	hh.PutBytes(h.Target[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the HardBitvectorStruct object
func (h *HardBitvectorStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(h)
}

// MarshalSSZ ssz marshals the HardNestedContainer object
func (h *HardNestedContainer) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(h)
}

// MarshalSSZTo ssz marshals the HardNestedContainer object to a target array
func (h *HardNestedContainer) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset := h.fixedSize()

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Field (0) 'InnerPadding'
	dst = append(dst, h.InnerPadding[:]...)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Offset (1) 'A'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset += len(h.A) * 8

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Offset (2) 'B'
	dst = ssz.WriteOffset(dst, offset)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (3) 'C'
	dst = ssz.MarshalValue(dst, h.C)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (1) 'A'
	if size := uint64(len(h.A)); size > 128 {
		err = ssz.ErrListTooBigFn("HardNestedContainer.A", size, 128)
		tracer.Record(13792041702645271617, tracer.ToScalar(err))
		return
	}
	for ii := 0; ii < len(h.A); ii++ {
		dst = ssz.MarshalValue(dst, h.A[ii])
		tracer.Record(17343663318883810848, tracer.ToScalar(dst))
	}

	// Field (2) 'B'
	if size := uint64(len(h.B)); size > 1024 {
		err = ssz.ErrBytesLengthFn("HardNestedContainer.B", size, 1024)
		tracer.Record(41879210796514867, tracer.ToScalar(err))
		return
	}
	dst = append(dst, h.B...)

	tracer.Record(17961113889319673671, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the HardNestedContainer object
func (h *HardNestedContainer) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(h, buf)
}

// UnmarshalSSZTail unmarshals the HardNestedContainer object and returns the remaining bufferº
func (h *HardNestedContainer) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(8402617314992080774, tracer.ToScalar(size))
	fixedSize := h.fixedSize()
	tracer.Record(194556321646530282, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	tracer.Record(8400561470327127284, tracer.ToScalar(tail))
	var o1, o2 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	tracer.Record(13759569719659226616, tracer.ToScalar(marker))

	// Field (0) 'InnerPadding'
	buf = ssz.UnmarshalFixedBytes(h.InnerPadding[:], buf)

	tracer.Record(16046195392382727211, tracer.ToScalar(buf))

	// Offset (1) 'A'
	if o1, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (2) 'B'
	if o2, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (3) 'C'
	h.C, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(10662212202602360237, tracer.ToScalar(buf))

	// Field (1) 'A'
	if err = ssz.UnmarshalSliceWithIndexCallback(&h.A, tail[o1:o2], 8, 128, func(ii uint64, buf []byte) (err error) {
		h.A[ii], buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(13654044939386056828, tracer.ToScalar(buf))
		return nil
	}); err != nil {
		return nil, err
	}

	// Field (2) 'B'
	if h.B, err = ssz.UnmarshalDynamicBytes(h.B, tail[o2:], 1024); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the HardNestedContainer object
func (h *HardNestedContainer) fixedSize() int {
	return int(1040)
}

// SizeSSZ returns the ssz encoded size in bytes for the HardNestedContainer object
func (h *HardNestedContainer) SizeSSZ() (size int) {
	size = h.fixedSize()

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (1) 'A'
	size += len(h.A) * 8

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (2) 'B'
	size += len(h.B)

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	return
}

// HashTreeRoot ssz hashes the HardNestedContainer object
func (h *HardNestedContainer) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(h)
}

// HashTreeRootWith ssz hashes the HardNestedContainer object with a hasher
func (h *HardNestedContainer) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(9124548103629576633, tracer.ToScalar(indx))

	// Field (0) 'InnerPadding'
	hh.PutBytes(h.InnerPadding[:])

	// Field (1) 'A'
	{
		if size := uint64(len(h.A)); size > 128 {
			err = ssz.ErrListTooBigFn("HardNestedContainer.A", size, 128)
			tracer.Record(1756680335971179755, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(5337346028819207941, tracer.ToScalar(subIndx))
		for _, i := range h.A {
			hh.AppendUint64(i)
		}
		hh.FillUpTo32()
		numItems := uint64(len(h.A))
		tracer.Record(8760198177624827065, tracer.ToScalar(numItems))
		hh.MerkleizeWithMixin(subIndx, numItems, ssz.CalculateLimit(128, numItems, 8))
	}

	// Field (2) 'B'
	{
		elemIndx := hh.Index()
		tracer.Record(2942837163400678198, tracer.ToScalar(elemIndx))
		byteLen := uint64(len(h.B))
		tracer.Record(12068525842657807363, tracer.ToScalar(byteLen))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(10864966389090187078, tracer.ToScalar(err))
			return
		}
		hh.Append(h.B)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	// Field (3) 'C'
	hh.PutUint64(h.C)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the HardNestedContainer object
func (h *HardNestedContainer) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(h)
}

// MarshalSSZ ssz marshals the HardBooleanStruct object
func (h *HardBooleanStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(h)
}

// MarshalSSZTo ssz marshals the HardBooleanStruct object to a target array
func (h *HardBooleanStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset := h.fixedSize()

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, h.Magic)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (1) 'LargeBuffer'
	dst = append(dst, h.LargeBuffer[:]...)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Offset (2) 'Name'
	dst = ssz.WriteOffset(dst, offset)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (3) 'Age'
	dst = ssz.MarshalValue(dst, h.Age)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (4) 'Meta'
	if size := uint64(len(h.Meta)); size != 4 {
		err = ssz.ErrVectorLengthFn("HardBooleanStruct.Meta", size, 4)
		tracer.Record(13792041702645271617, tracer.ToScalar(err))
		return
	}
	for ii := uint64(0); ii < 4; ii++ {
		dst = ssz.MarshalValue(dst, h.Meta[ii])
		tracer.Record(17343663318883810848, tracer.ToScalar(dst))
	}

	// Field (5) 'Target'
	dst = ssz.MarshalValue(dst, h.Target)

	tracer.Record(17343663318883810848, tracer.ToScalar(dst))

	// Field (2) 'Name'
	if size := uint64(len(h.Name)); size > 256 {
		err = ssz.ErrBytesLengthFn("HardBooleanStruct.Name", size, 256)
		tracer.Record(41879210796514867, tracer.ToScalar(err))
		return
	}
	dst = append(dst, h.Name...)

	tracer.Record(17961113889319673671, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the HardBooleanStruct object
func (h *HardBooleanStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(h, buf)
}

// UnmarshalSSZTail unmarshals the HardBooleanStruct object and returns the remaining bufferº
func (h *HardBooleanStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(8402617314992080774, tracer.ToScalar(size))
	fixedSize := h.fixedSize()
	tracer.Record(194556321646530282, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	tracer.Record(8400561470327127284, tracer.ToScalar(tail))
	var o2 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	tracer.Record(13759569719659226616, tracer.ToScalar(marker))

	// Field (0) 'Magic'
	h.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(16046195392382727211, tracer.ToScalar(buf))

	// Field (1) 'LargeBuffer'
	buf = ssz.UnmarshalFixedBytes(h.LargeBuffer[:], buf)

	tracer.Record(16046195392382727211, tracer.ToScalar(buf))

	// Offset (2) 'Name'
	if o2, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (3) 'Age'
	h.Age, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(2234966005017096466, tracer.ToScalar(buf))

	// Field (4) 'Meta'
	h.Meta = ssz.Extend(h.Meta, 4)
	for ii := uint64(0); ii < 4; ii++ {
		h.Meta[ii], buf = ssz.UnmarshallValue[uint64](buf)
		tracer.Record(10662212202602360237, tracer.ToScalar(buf))
	}

	// Field (5) 'Target'
	h.Target, buf = ssz.UnmarshallValue[bool](buf)

	tracer.Record(10662212202602360237, tracer.ToScalar(buf))

	// Field (2) 'Name'
	if h.Name, err = ssz.UnmarshalDynamicBytes(h.Name, tail[o2:], 256); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the HardBooleanStruct object
func (h *HardBooleanStruct) fixedSize() int {
	return int(8245)
}

// SizeSSZ returns the ssz encoded size in bytes for the HardBooleanStruct object
func (h *HardBooleanStruct) SizeSSZ() (size int) {
	size = h.fixedSize()

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (2) 'Name'
	size += len(h.Name)

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	return
}

// HashTreeRoot ssz hashes the HardBooleanStruct object
func (h *HardBooleanStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(h)
}

// HashTreeRootWith ssz hashes the HardBooleanStruct object with a hasher
func (h *HardBooleanStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(9124548103629576633, tracer.ToScalar(indx))

	// Field (0) 'Magic'
	hh.PutUint64(h.Magic)

	// Field (1) 'LargeBuffer'
	hh.PutBytes(h.LargeBuffer[:])

	// Field (2) 'Name'
	{
		elemIndx := hh.Index()
		tracer.Record(17405718152972083287, tracer.ToScalar(elemIndx))
		byteLen := uint64(len(h.Name))
		tracer.Record(14665136328895629076, tracer.ToScalar(byteLen))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(1756680335971179755, tracer.ToScalar(err))
			return
		}
		hh.Append(h.Name)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (3) 'Age'
	hh.PutUint64(h.Age)

	// Field (4) 'Meta'
	{
		if size := uint64(len(h.Meta)); size != 4 {
			err = ssz.ErrVectorLengthFn("HardBooleanStruct.Meta", size, 4)
			tracer.Record(12331136582161734617, tracer.ToScalar(err))
			return
		}
		subIndx := hh.Index()
		tracer.Record(13639080197730594063, tracer.ToScalar(subIndx))
		for _, i := range h.Meta {
			hh.AppendUint64(i)
		}
		hh.Merkleize(subIndx)
	}

	// Field (5) 'Target'
	hh.PutBool(h.Target)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the HardBooleanStruct object
func (h *HardBooleanStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(h)
}

// MarshalSSZ ssz marshals the HardGapStruct object
func (h *HardGapStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(h)
}

// MarshalSSZTo ssz marshals the HardGapStruct object to a target array
func (h *HardGapStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset := h.fixedSize()

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, h.Magic)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (1) 'Padding'
	dst = append(dst, h.Padding[:]...)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (2) 'Header'
	dst = ssz.MarshalValue(dst, h.Header)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Offset (3) 'Payload1'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset += len(h.Payload1)

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Offset (4) 'Payload2'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset += len(h.Payload2)

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Offset (5) 'Payload3'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset += len(h.Payload3)

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Offset (6) 'Payload4'
	dst = ssz.WriteOffset(dst, offset)
	tracer.Record(9716298303570142010, tracer.ToScalar(dst))
	offset += len(h.Payload4)

	tracer.Record(17675791446996146504, tracer.ToScalar(offset))

	// Offset (7) 'Payload5'
	dst = ssz.WriteOffset(dst, offset)

	tracer.Record(9716298303570142010, tracer.ToScalar(dst))

	// Field (3) 'Payload1'
	if size := uint64(len(h.Payload1)); size > 1024 {
		err = ssz.ErrBytesLengthFn("HardGapStruct.Payload1", size, 1024)
		tracer.Record(13792041702645271617, tracer.ToScalar(err))
		return
	}
	dst = append(dst, h.Payload1...)

	tracer.Record(13287582469228152809, tracer.ToScalar(dst))

	// Field (4) 'Payload2'
	if size := uint64(len(h.Payload2)); size > 1024 {
		err = ssz.ErrBytesLengthFn("HardGapStruct.Payload2", size, 1024)
		tracer.Record(16816149525650905192, tracer.ToScalar(err))
		return
	}
	dst = append(dst, h.Payload2...)

	tracer.Record(17343663318883810848, tracer.ToScalar(dst))

	// Field (5) 'Payload3'
	if size := uint64(len(h.Payload3)); size > 1024 {
		err = ssz.ErrBytesLengthFn("HardGapStruct.Payload3", size, 1024)
		tracer.Record(41879210796514867, tracer.ToScalar(err))
		return
	}
	dst = append(dst, h.Payload3...)

	tracer.Record(17961113889319673671, tracer.ToScalar(dst))

	// Field (6) 'Payload4'
	if size := uint64(len(h.Payload4)); size > 1024 {
		err = ssz.ErrBytesLengthFn("HardGapStruct.Payload4", size, 1024)
		tracer.Record(1034036773705367834, tracer.ToScalar(err))
		return
	}
	dst = append(dst, h.Payload4...)

	tracer.Record(1569163585450492654, tracer.ToScalar(dst))

	// Field (7) 'Payload5'
	if size := uint64(len(h.Payload5)); size > 1024 {
		err = ssz.ErrBytesLengthFn("HardGapStruct.Payload5", size, 1024)
		tracer.Record(12639656908869750109, tracer.ToScalar(err))
		return
	}
	dst = append(dst, h.Payload5...)

	tracer.Record(12104525699078112445, tracer.ToScalar(dst))

	return
}

// UnmarshalSSZ ssz unmarshals the HardGapStruct object
func (h *HardGapStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(h, buf)
}

// UnmarshalSSZTail unmarshals the HardGapStruct object and returns the remaining bufferº
func (h *HardGapStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	tracer.Record(8402617314992080774, tracer.ToScalar(size))
	fixedSize := h.fixedSize()
	tracer.Record(194556321646530282, tracer.ToScalar(fixedSize))
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	tracer.Record(8400561470327127284, tracer.ToScalar(tail))
	var o3, o4, o5, o6, o7 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	tracer.Record(13759569719659226616, tracer.ToScalar(marker))

	// Field (0) 'Magic'
	h.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(16046195392382727211, tracer.ToScalar(buf))

	// Field (1) 'Padding'
	buf = ssz.UnmarshalFixedBytes(h.Padding[:], buf)

	tracer.Record(16046195392382727211, tracer.ToScalar(buf))

	// Field (2) 'Header'
	h.Header, buf = ssz.UnmarshallValue[uint64](buf)

	tracer.Record(16046195392382727211, tracer.ToScalar(buf))

	// Offset (3) 'Payload1'
	if o3, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (4) 'Payload2'
	if o4, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (5) 'Payload3'
	if o5, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (6) 'Payload4'
	if o6, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (7) 'Payload5'
	if o7, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (3) 'Payload1'
	if h.Payload1, err = ssz.UnmarshalDynamicBytes(h.Payload1, tail[o3:o4], 1024); err != nil {
		return
	}

	// Field (4) 'Payload2'
	if h.Payload2, err = ssz.UnmarshalDynamicBytes(h.Payload2, tail[o4:o5], 1024); err != nil {
		return
	}

	// Field (5) 'Payload3'
	if h.Payload3, err = ssz.UnmarshalDynamicBytes(h.Payload3, tail[o5:o6], 1024); err != nil {
		return
	}

	// Field (6) 'Payload4'
	if h.Payload4, err = ssz.UnmarshalDynamicBytes(h.Payload4, tail[o6:o7], 1024); err != nil {
		return
	}

	// Field (7) 'Payload5'
	if h.Payload5, err = ssz.UnmarshalDynamicBytes(h.Payload5, tail[o7:], 1024); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the HardGapStruct object
func (h *HardGapStruct) fixedSize() int {
	return int(4132)
}

// SizeSSZ returns the ssz encoded size in bytes for the HardGapStruct object
func (h *HardGapStruct) SizeSSZ() (size int) {
	size = h.fixedSize()

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (3) 'Payload1'
	size += len(h.Payload1)

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (4) 'Payload2'
	size += len(h.Payload2)

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (5) 'Payload3'
	size += len(h.Payload3)

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (6) 'Payload4'
	size += len(h.Payload4)

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	// Field (7) 'Payload5'
	size += len(h.Payload5)

	tracer.Record(9993598622769301344, tracer.ToScalar(size))

	return
}

// HashTreeRoot ssz hashes the HardGapStruct object
func (h *HardGapStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(h)
}

// HashTreeRootWith ssz hashes the HardGapStruct object with a hasher
func (h *HardGapStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	tracer.Record(9124548103629576633, tracer.ToScalar(indx))

	// Field (0) 'Magic'
	hh.PutUint64(h.Magic)

	// Field (1) 'Padding'
	hh.PutBytes(h.Padding[:])

	// Field (2) 'Header'
	hh.PutUint64(h.Header)

	// Field (3) 'Payload1'
	{
		elemIndx := hh.Index()
		tracer.Record(17405718152972083287, tracer.ToScalar(elemIndx))
		byteLen := uint64(len(h.Payload1))
		tracer.Record(14665136328895629076, tracer.ToScalar(byteLen))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(1756680335971179755, tracer.ToScalar(err))
			return
		}
		hh.Append(h.Payload1)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	// Field (4) 'Payload2'
	{
		elemIndx := hh.Index()
		tracer.Record(16342388273865230101, tracer.ToScalar(elemIndx))
		byteLen := uint64(len(h.Payload2))
		tracer.Record(16971652474385578354, tracer.ToScalar(byteLen))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(12331136582161734617, tracer.ToScalar(err))
			return
		}
		hh.Append(h.Payload2)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	// Field (5) 'Payload3'
	{
		elemIndx := hh.Index()
		tracer.Record(16699059459491840875, tracer.ToScalar(elemIndx))
		byteLen := uint64(len(h.Payload3))
		tracer.Record(11347222381152722040, tracer.ToScalar(byteLen))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(9658923028211091103, tracer.ToScalar(err))
			return
		}
		hh.Append(h.Payload3)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	// Field (6) 'Payload4'
	{
		elemIndx := hh.Index()
		tracer.Record(8723181246972075321, tracer.ToScalar(elemIndx))
		byteLen := uint64(len(h.Payload4))
		tracer.Record(14071726907561064470, tracer.ToScalar(byteLen))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(11258620599494846269, tracer.ToScalar(err))
			return
		}
		hh.Append(h.Payload4)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	// Field (7) 'Payload5'
	{
		elemIndx := hh.Index()
		tracer.Record(13177179462817742518, tracer.ToScalar(elemIndx))
		byteLen := uint64(len(h.Payload5))
		tracer.Record(16988616026277399171, tracer.ToScalar(byteLen))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			tracer.Record(11668481690631710560, tracer.ToScalar(err))
			return
		}
		hh.Append(h.Payload5)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the HardGapStruct object
func (h *HardGapStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(h)
}
