// Code generated by fastssz. DO NOT EDIT.
// Hash: 89b8822fa728bb55cebcf8e1429b3098607f2aea8b28bd91a5c08bf0ad19f4e1
// Version: 2.0.0
package schemas

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the BitvectorPairStruct object
func (b *BitvectorPairStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitvectorPairStruct object to a target array
func (b *BitvectorPairStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Field (1) 'BitsA'
	dst = append(dst, b.BitsA[:]...)

	// Field (2) 'BitsB'
	dst = append(dst, b.BitsB[:]...)

	// Field (3) 'Padding'
	dst = append(dst, b.Padding[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitvectorPairStruct object
func (b *BitvectorPairStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitvectorPairStruct object and returns the remaining bufferº
func (b *BitvectorPairStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'BitsA'
	buf = ssz.UnmarshalFixedBytes(b.BitsA[:], buf)

	// Field (2) 'BitsB'
	buf = ssz.UnmarshalFixedBytes(b.BitsB[:], buf)

	// Field (3) 'Padding'
	buf = ssz.UnmarshalFixedBytes(b.Padding[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BitvectorPairStruct object
func (b *BitvectorPairStruct) fixedSize() int {
	return int(138)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitvectorPairStruct object
func (b *BitvectorPairStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BitvectorPairStruct object
func (b *BitvectorPairStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitvectorPairStruct object with a hasher
func (b *BitvectorPairStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'BitsA'
	hh.PutBytes(b.BitsA[:])

	// Field (2) 'BitsB'
	hh.PutBytes(b.BitsB[:])

	// Field (3) 'Padding'
	hh.PutBytes(b.Padding[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitvectorPairStruct object
func (b *BitvectorPairStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BitvectorWideStruct object
func (b *BitvectorWideStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitvectorWideStruct object to a target array
func (b *BitvectorWideStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Field (1) 'Padding'
	dst = append(dst, b.Padding[:]...)

	// Field (2) 'BitsA'
	dst = append(dst, b.BitsA[:]...)

	// Field (3) 'BitsB'
	dst = append(dst, b.BitsB[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitvectorWideStruct object
func (b *BitvectorWideStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitvectorWideStruct object and returns the remaining bufferº
func (b *BitvectorWideStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'Padding'
	buf = ssz.UnmarshalFixedBytes(b.Padding[:], buf)

	// Field (2) 'BitsA'
	buf = ssz.UnmarshalFixedBytes(b.BitsA[:], buf)

	// Field (3) 'BitsB'
	buf = ssz.UnmarshalFixedBytes(b.BitsB[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BitvectorWideStruct object
func (b *BitvectorWideStruct) fixedSize() int {
	return int(4106)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitvectorWideStruct object
func (b *BitvectorWideStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BitvectorWideStruct object
func (b *BitvectorWideStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitvectorWideStruct object with a hasher
func (b *BitvectorWideStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'Padding'
	hh.PutBytes(b.Padding[:])

	// Field (2) 'BitsA'
	hh.PutBytes(b.BitsA[:])

	// Field (3) 'BitsB'
	hh.PutBytes(b.BitsB[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitvectorWideStruct object
func (b *BitvectorWideStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BitvectorOffsetStruct object
func (b *BitvectorOffsetStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitvectorOffsetStruct object to a target array
func (b *BitvectorOffsetStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Field (1) 'BitsA'
	dst = append(dst, b.BitsA[:]...)

	// Offset (2) 'PayloadA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.PayloadA)

	// Field (3) 'BitsB'
	dst = append(dst, b.BitsB[:]...)

	// Offset (4) 'PayloadB'
	dst = ssz.WriteOffset(dst, offset)

	// Field (2) 'PayloadA'
	if size := uint64(len(b.PayloadA)); size > 512 {
		err = ssz.ErrBytesLengthFn("BitvectorOffsetStruct.PayloadA", size, 512)
		return
	}
	dst = append(dst, b.PayloadA...)

	// Field (4) 'PayloadB'
	if size := uint64(len(b.PayloadB)); size > 512 {
		err = ssz.ErrBytesLengthFn("BitvectorOffsetStruct.PayloadB", size, 512)
		return
	}
	dst = append(dst, b.PayloadB...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitvectorOffsetStruct object
func (b *BitvectorOffsetStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitvectorOffsetStruct object and returns the remaining bufferº
func (b *BitvectorOffsetStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o2, o4 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'BitsA'
	buf = ssz.UnmarshalFixedBytes(b.BitsA[:], buf)

	// Offset (2) 'PayloadA'
	if o2, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (3) 'BitsB'
	buf = ssz.UnmarshalFixedBytes(b.BitsB[:], buf)

	// Offset (4) 'PayloadB'
	if o4, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (2) 'PayloadA'
	if b.PayloadA, err = ssz.UnmarshalDynamicBytes(b.PayloadA, tail[o2:o4], 512); err != nil {
		return
	}

	// Field (4) 'PayloadB'
	if b.PayloadB, err = ssz.UnmarshalDynamicBytes(b.PayloadB, tail[o4:], 512); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the BitvectorOffsetStruct object
func (b *BitvectorOffsetStruct) fixedSize() int {
	return int(18)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitvectorOffsetStruct object
func (b *BitvectorOffsetStruct) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (2) 'PayloadA'
	size += len(b.PayloadA)

	// Field (4) 'PayloadB'
	size += len(b.PayloadB)

	return
}

// HashTreeRoot ssz hashes the BitvectorOffsetStruct object
func (b *BitvectorOffsetStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitvectorOffsetStruct object with a hasher
func (b *BitvectorOffsetStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'BitsA'
	hh.PutBytes(b.BitsA[:])

	// Field (2) 'PayloadA'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(b.PayloadA))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(b.PayloadA)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	// Field (3) 'BitsB'
	hh.PutBytes(b.BitsB[:])

	// Field (4) 'PayloadB'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(b.PayloadB))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(b.PayloadB)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitvectorOffsetStruct object
func (b *BitvectorOffsetStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BitvectorScatterStruct object
func (b *BitvectorScatterStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitvectorScatterStruct object to a target array
func (b *BitvectorScatterStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Field (1) 'BitsA'
	dst = append(dst, b.BitsA[:]...)

	// Field (2) 'PaddingA'
	dst = append(dst, b.PaddingA[:]...)

	// Field (3) 'BitsB'
	dst = append(dst, b.BitsB[:]...)

	// Field (4) 'PaddingB'
	dst = append(dst, b.PaddingB[:]...)

	// Field (5) 'BitsC'
	dst = append(dst, b.BitsC[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitvectorScatterStruct object
func (b *BitvectorScatterStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitvectorScatterStruct object and returns the remaining bufferº
func (b *BitvectorScatterStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'BitsA'
	buf = ssz.UnmarshalFixedBytes(b.BitsA[:], buf)

	// Field (2) 'PaddingA'
	buf = ssz.UnmarshalFixedBytes(b.PaddingA[:], buf)

	// Field (3) 'BitsB'
	buf = ssz.UnmarshalFixedBytes(b.BitsB[:], buf)

	// Field (4) 'PaddingB'
	buf = ssz.UnmarshalFixedBytes(b.PaddingB[:], buf)

	// Field (5) 'BitsC'
	buf = ssz.UnmarshalFixedBytes(b.BitsC[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BitvectorScatterStruct object
func (b *BitvectorScatterStruct) fixedSize() int {
	return int(779)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitvectorScatterStruct object
func (b *BitvectorScatterStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BitvectorScatterStruct object
func (b *BitvectorScatterStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitvectorScatterStruct object with a hasher
func (b *BitvectorScatterStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'BitsA'
	hh.PutBytes(b.BitsA[:])

	// Field (2) 'PaddingA'
	hh.PutBytes(b.PaddingA[:])

	// Field (3) 'BitsB'
	hh.PutBytes(b.BitsB[:])

	// Field (4) 'PaddingB'
	hh.PutBytes(b.PaddingB[:])

	// Field (5) 'BitsC'
	hh.PutBytes(b.BitsC[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitvectorScatterStruct object
func (b *BitvectorScatterStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BooleanPairStruct object
func (b *BooleanPairStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BooleanPairStruct object to a target array
func (b *BooleanPairStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Field (1) 'FlagA'
	dst = ssz.MarshalValue(dst, b.FlagA)

	// Field (2) 'FlagB'
	dst = ssz.MarshalValue(dst, b.FlagB)

	// Field (3) 'Padding'
	dst = append(dst, b.Padding[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BooleanPairStruct object
func (b *BooleanPairStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BooleanPairStruct object and returns the remaining bufferº
func (b *BooleanPairStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'FlagA'
	b.FlagA, buf = ssz.UnmarshallValue[bool](buf)

	// Field (2) 'FlagB'
	b.FlagB, buf = ssz.UnmarshallValue[bool](buf)

	// Field (3) 'Padding'
	buf = ssz.UnmarshalFixedBytes(b.Padding[:], buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BooleanPairStruct object
func (b *BooleanPairStruct) fixedSize() int {
	return int(138)
}

// SizeSSZ returns the ssz encoded size in bytes for the BooleanPairStruct object
func (b *BooleanPairStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BooleanPairStruct object
func (b *BooleanPairStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BooleanPairStruct object with a hasher
func (b *BooleanPairStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'FlagA'
	hh.PutBool(b.FlagA)

	// Field (2) 'FlagB'
	hh.PutBool(b.FlagB)

	// Field (3) 'Padding'
	hh.PutBytes(b.Padding[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BooleanPairStruct object
func (b *BooleanPairStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BooleanWideStruct object
func (b *BooleanWideStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BooleanWideStruct object to a target array
func (b *BooleanWideStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Field (1) 'Padding'
	dst = append(dst, b.Padding[:]...)

	// Field (2) 'FlagA'
	dst = ssz.MarshalValue(dst, b.FlagA)

	// Field (3) 'FlagB'
	dst = ssz.MarshalValue(dst, b.FlagB)

	return
}

// UnmarshalSSZ ssz unmarshals the BooleanWideStruct object
func (b *BooleanWideStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BooleanWideStruct object and returns the remaining bufferº
func (b *BooleanWideStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'Padding'
	buf = ssz.UnmarshalFixedBytes(b.Padding[:], buf)

	// Field (2) 'FlagA'
	b.FlagA, buf = ssz.UnmarshallValue[bool](buf)

	// Field (3) 'FlagB'
	b.FlagB, buf = ssz.UnmarshallValue[bool](buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BooleanWideStruct object
func (b *BooleanWideStruct) fixedSize() int {
	return int(8202)
}

// SizeSSZ returns the ssz encoded size in bytes for the BooleanWideStruct object
func (b *BooleanWideStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BooleanWideStruct object
func (b *BooleanWideStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BooleanWideStruct object with a hasher
func (b *BooleanWideStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'Padding'
	hh.PutBytes(b.Padding[:])

	// Field (2) 'FlagA'
	hh.PutBool(b.FlagA)

	// Field (3) 'FlagB'
	hh.PutBool(b.FlagB)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BooleanWideStruct object
func (b *BooleanWideStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BooleanOffsetStruct object
func (b *BooleanOffsetStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BooleanOffsetStruct object to a target array
func (b *BooleanOffsetStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Field (1) 'FlagA'
	dst = ssz.MarshalValue(dst, b.FlagA)

	// Offset (2) 'PayloadA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.PayloadA)

	// Field (3) 'FlagB'
	dst = ssz.MarshalValue(dst, b.FlagB)

	// Offset (4) 'PayloadB'
	dst = ssz.WriteOffset(dst, offset)

	// Field (5) 'FlagC'
	dst = ssz.MarshalValue(dst, b.FlagC)

	// Field (2) 'PayloadA'
	if size := uint64(len(b.PayloadA)); size > 256 {
		err = ssz.ErrBytesLengthFn("BooleanOffsetStruct.PayloadA", size, 256)
		return
	}
	dst = append(dst, b.PayloadA...)

	// Field (4) 'PayloadB'
	if size := uint64(len(b.PayloadB)); size > 256 {
		err = ssz.ErrBytesLengthFn("BooleanOffsetStruct.PayloadB", size, 256)
		return
	}
	dst = append(dst, b.PayloadB...)

	return
}

// UnmarshalSSZ ssz unmarshals the BooleanOffsetStruct object
func (b *BooleanOffsetStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BooleanOffsetStruct object and returns the remaining bufferº
func (b *BooleanOffsetStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o2, o4 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'FlagA'
	b.FlagA, buf = ssz.UnmarshallValue[bool](buf)

	// Offset (2) 'PayloadA'
	if o2, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (3) 'FlagB'
	b.FlagB, buf = ssz.UnmarshallValue[bool](buf)

	// Offset (4) 'PayloadB'
	if o4, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (5) 'FlagC'
	b.FlagC, buf = ssz.UnmarshallValue[bool](buf)

	// Field (2) 'PayloadA'
	if b.PayloadA, err = ssz.UnmarshalDynamicBytes(b.PayloadA, tail[o2:o4], 256); err != nil {
		return
	}

	// Field (4) 'PayloadB'
	if b.PayloadB, err = ssz.UnmarshalDynamicBytes(b.PayloadB, tail[o4:], 256); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the BooleanOffsetStruct object
func (b *BooleanOffsetStruct) fixedSize() int {
	return int(19)
}

// SizeSSZ returns the ssz encoded size in bytes for the BooleanOffsetStruct object
func (b *BooleanOffsetStruct) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (2) 'PayloadA'
	size += len(b.PayloadA)

	// Field (4) 'PayloadB'
	size += len(b.PayloadB)

	return
}

// HashTreeRoot ssz hashes the BooleanOffsetStruct object
func (b *BooleanOffsetStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BooleanOffsetStruct object with a hasher
func (b *BooleanOffsetStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'FlagA'
	hh.PutBool(b.FlagA)

	// Field (2) 'PayloadA'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(b.PayloadA))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(b.PayloadA)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (3) 'FlagB'
	hh.PutBool(b.FlagB)

	// Field (4) 'PayloadB'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(b.PayloadB))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(b.PayloadB)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (5) 'FlagC'
	hh.PutBool(b.FlagC)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BooleanOffsetStruct object
func (b *BooleanOffsetStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BooleanScatterStruct object
func (b *BooleanScatterStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BooleanScatterStruct object to a target array
func (b *BooleanScatterStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Field (1) 'FlagA'
	dst = ssz.MarshalValue(dst, b.FlagA)

	// Field (2) 'PaddingA'
	dst = append(dst, b.PaddingA[:]...)

	// Field (3) 'FlagB'
	dst = ssz.MarshalValue(dst, b.FlagB)

	// Field (4) 'PaddingB'
	dst = append(dst, b.PaddingB[:]...)

	// Field (5) 'FlagC'
	dst = ssz.MarshalValue(dst, b.FlagC)

	return
}

// UnmarshalSSZ ssz unmarshals the BooleanScatterStruct object
func (b *BooleanScatterStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BooleanScatterStruct object and returns the remaining bufferº
func (b *BooleanScatterStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'FlagA'
	b.FlagA, buf = ssz.UnmarshallValue[bool](buf)

	// Field (2) 'PaddingA'
	buf = ssz.UnmarshalFixedBytes(b.PaddingA[:], buf)

	// Field (3) 'FlagB'
	b.FlagB, buf = ssz.UnmarshallValue[bool](buf)

	// Field (4) 'PaddingB'
	buf = ssz.UnmarshalFixedBytes(b.PaddingB[:], buf)

	// Field (5) 'FlagC'
	b.FlagC, buf = ssz.UnmarshallValue[bool](buf)

	return buf, nil
}

// fixedSize returns the fixed size of the BooleanScatterStruct object
func (b *BooleanScatterStruct) fixedSize() int {
	return int(395)
}

// SizeSSZ returns the ssz encoded size in bytes for the BooleanScatterStruct object
func (b *BooleanScatterStruct) SizeSSZ() (size int) {
	size = b.fixedSize()
	return
}

// HashTreeRoot ssz hashes the BooleanScatterStruct object
func (b *BooleanScatterStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BooleanScatterStruct object with a hasher
func (b *BooleanScatterStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'FlagA'
	hh.PutBool(b.FlagA)

	// Field (2) 'PaddingA'
	hh.PutBytes(b.PaddingA[:])

	// Field (3) 'FlagB'
	hh.PutBool(b.FlagB)

	// Field (4) 'PaddingB'
	hh.PutBytes(b.PaddingB[:])

	// Field (5) 'FlagC'
	hh.PutBool(b.FlagC)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BooleanScatterStruct object
func (b *BooleanScatterStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BitlistPairStruct object
func (b *BitlistPairStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitlistPairStruct object to a target array
func (b *BitlistPairStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Offset (0) 'BitsA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.BitsA)

	// Offset (1) 'BitsB'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'BitsA'
	if size := ssz.BitlistLen(b.BitsA); size > 2048 {
		err = ssz.ErrBytesLengthFn("BitlistPairStruct.BitsA", size, 2048)
		return
	}
	dst = append(dst, b.BitsA...)

	// Field (1) 'BitsB'
	if size := ssz.BitlistLen(b.BitsB); size > 2048 {
		err = ssz.ErrBytesLengthFn("BitlistPairStruct.BitsB", size, 2048)
		return
	}
	dst = append(dst, b.BitsB...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitlistPairStruct object
func (b *BitlistPairStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitlistPairStruct object and returns the remaining bufferº
func (b *BitlistPairStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'BitsA'
	if o0, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (1) 'BitsB'
	if o1, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (0) 'BitsA'
	if b.BitsA, err = ssz.UnmarshalBitList(b.BitsA, tail[o0:o1], 2048); err != nil {
		return nil, err
	}

	// Field (1) 'BitsB'
	if b.BitsB, err = ssz.UnmarshalBitList(b.BitsB, tail[o1:], 2048); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BitlistPairStruct object
func (b *BitlistPairStruct) fixedSize() int {
	return int(8)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitlistPairStruct object
func (b *BitlistPairStruct) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (0) 'BitsA'
	size += len(b.BitsA)

	// Field (1) 'BitsB'
	size += len(b.BitsB)

	return
}

// HashTreeRoot ssz hashes the BitlistPairStruct object
func (b *BitlistPairStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitlistPairStruct object with a hasher
func (b *BitlistPairStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BitsA'
	if len(b.BitsA) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.BitsA, 2048)

	// Field (1) 'BitsB'
	if len(b.BitsB) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.BitsB, 2048)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitlistPairStruct object
func (b *BitlistPairStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BitlistWideStruct object
func (b *BitlistWideStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitlistWideStruct object to a target array
func (b *BitlistWideStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Field (1) 'Padding'
	dst = append(dst, b.Padding[:]...)

	// Offset (2) 'BitsA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.BitsA)

	// Offset (3) 'BitsB'
	dst = ssz.WriteOffset(dst, offset)

	// Field (2) 'BitsA'
	if size := ssz.BitlistLen(b.BitsA); size > 2048 {
		err = ssz.ErrBytesLengthFn("BitlistWideStruct.BitsA", size, 2048)
		return
	}
	dst = append(dst, b.BitsA...)

	// Field (3) 'BitsB'
	if size := ssz.BitlistLen(b.BitsB); size > 2048 {
		err = ssz.ErrBytesLengthFn("BitlistWideStruct.BitsB", size, 2048)
		return
	}
	dst = append(dst, b.BitsB...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitlistWideStruct object
func (b *BitlistWideStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitlistWideStruct object and returns the remaining bufferº
func (b *BitlistWideStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o2, o3 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'Padding'
	buf = ssz.UnmarshalFixedBytes(b.Padding[:], buf)

	// Offset (2) 'BitsA'
	if o2, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (3) 'BitsB'
	if o3, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (2) 'BitsA'
	if b.BitsA, err = ssz.UnmarshalBitList(b.BitsA, tail[o2:o3], 2048); err != nil {
		return nil, err
	}

	// Field (3) 'BitsB'
	if b.BitsB, err = ssz.UnmarshalBitList(b.BitsB, tail[o3:], 2048); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BitlistWideStruct object
func (b *BitlistWideStruct) fixedSize() int {
	return int(2064)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitlistWideStruct object
func (b *BitlistWideStruct) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (2) 'BitsA'
	size += len(b.BitsA)

	// Field (3) 'BitsB'
	size += len(b.BitsB)

	return
}

// HashTreeRoot ssz hashes the BitlistWideStruct object
func (b *BitlistWideStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitlistWideStruct object with a hasher
func (b *BitlistWideStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'Padding'
	hh.PutBytes(b.Padding[:])

	// Field (2) 'BitsA'
	if len(b.BitsA) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.BitsA, 2048)

	// Field (3) 'BitsB'
	if len(b.BitsB) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.BitsB, 2048)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitlistWideStruct object
func (b *BitlistWideStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BitlistTriStruct object
func (b *BitlistTriStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitlistTriStruct object to a target array
func (b *BitlistTriStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Offset (0) 'BitsA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.BitsA)

	// Offset (1) 'BitsB'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.BitsB)

	// Offset (2) 'BitsC'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'BitsA'
	if size := ssz.BitlistLen(b.BitsA); size > 2048 {
		err = ssz.ErrBytesLengthFn("BitlistTriStruct.BitsA", size, 2048)
		return
	}
	dst = append(dst, b.BitsA...)

	// Field (1) 'BitsB'
	if size := ssz.BitlistLen(b.BitsB); size > 2048 {
		err = ssz.ErrBytesLengthFn("BitlistTriStruct.BitsB", size, 2048)
		return
	}
	dst = append(dst, b.BitsB...)

	// Field (2) 'BitsC'
	if size := ssz.BitlistLen(b.BitsC); size > 2048 {
		err = ssz.ErrBytesLengthFn("BitlistTriStruct.BitsC", size, 2048)
		return
	}
	dst = append(dst, b.BitsC...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitlistTriStruct object
func (b *BitlistTriStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitlistTriStruct object and returns the remaining bufferº
func (b *BitlistTriStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o0, o1, o2 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Offset (0) 'BitsA'
	if o0, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (1) 'BitsB'
	if o1, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (2) 'BitsC'
	if o2, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (0) 'BitsA'
	if b.BitsA, err = ssz.UnmarshalBitList(b.BitsA, tail[o0:o1], 2048); err != nil {
		return nil, err
	}

	// Field (1) 'BitsB'
	if b.BitsB, err = ssz.UnmarshalBitList(b.BitsB, tail[o1:o2], 2048); err != nil {
		return nil, err
	}

	// Field (2) 'BitsC'
	if b.BitsC, err = ssz.UnmarshalBitList(b.BitsC, tail[o2:], 2048); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BitlistTriStruct object
func (b *BitlistTriStruct) fixedSize() int {
	return int(12)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitlistTriStruct object
func (b *BitlistTriStruct) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (0) 'BitsA'
	size += len(b.BitsA)

	// Field (1) 'BitsB'
	size += len(b.BitsB)

	// Field (2) 'BitsC'
	size += len(b.BitsC)

	return
}

// HashTreeRoot ssz hashes the BitlistTriStruct object
func (b *BitlistTriStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitlistTriStruct object with a hasher
func (b *BitlistTriStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BitsA'
	if len(b.BitsA) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.BitsA, 2048)

	// Field (1) 'BitsB'
	if len(b.BitsB) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.BitsB, 2048)

	// Field (2) 'BitsC'
	if len(b.BitsC) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.BitsC, 2048)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitlistTriStruct object
func (b *BitlistTriStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BitlistOffsetStruct object
func (b *BitlistOffsetStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BitlistOffsetStruct object to a target array
func (b *BitlistOffsetStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := b.fixedSize()

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, b.Magic)

	// Offset (1) 'BitsA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.BitsA)

	// Offset (2) 'Payload'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Payload)

	// Offset (3) 'BitsB'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'BitsA'
	if size := ssz.BitlistLen(b.BitsA); size > 1024 {
		err = ssz.ErrBytesLengthFn("BitlistOffsetStruct.BitsA", size, 1024)
		return
	}
	dst = append(dst, b.BitsA...)

	// Field (2) 'Payload'
	if size := uint64(len(b.Payload)); size > 512 {
		err = ssz.ErrBytesLengthFn("BitlistOffsetStruct.Payload", size, 512)
		return
	}
	dst = append(dst, b.Payload...)

	// Field (3) 'BitsB'
	if size := ssz.BitlistLen(b.BitsB); size > 1024 {
		err = ssz.ErrBytesLengthFn("BitlistOffsetStruct.BitsB", size, 1024)
		return
	}
	dst = append(dst, b.BitsB...)

	return
}

// UnmarshalSSZ ssz unmarshals the BitlistOffsetStruct object
func (b *BitlistOffsetStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(b, buf)
}

// UnmarshalSSZTail unmarshals the BitlistOffsetStruct object and returns the remaining bufferº
func (b *BitlistOffsetStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := b.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o1, o2, o3 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'Magic'
	b.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Offset (1) 'BitsA'
	if o1, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (2) 'Payload'
	if o2, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (3) 'BitsB'
	if o3, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'BitsA'
	if b.BitsA, err = ssz.UnmarshalBitList(b.BitsA, tail[o1:o2], 1024); err != nil {
		return nil, err
	}

	// Field (2) 'Payload'
	if b.Payload, err = ssz.UnmarshalDynamicBytes(b.Payload, tail[o2:o3], 512); err != nil {
		return
	}

	// Field (3) 'BitsB'
	if b.BitsB, err = ssz.UnmarshalBitList(b.BitsB, tail[o3:], 1024); err != nil {
		return nil, err
	}

	return
}

// fixedSize returns the fixed size of the BitlistOffsetStruct object
func (b *BitlistOffsetStruct) fixedSize() int {
	return int(20)
}

// SizeSSZ returns the ssz encoded size in bytes for the BitlistOffsetStruct object
func (b *BitlistOffsetStruct) SizeSSZ() (size int) {
	size = b.fixedSize()

	// Field (1) 'BitsA'
	size += len(b.BitsA)

	// Field (2) 'Payload'
	size += len(b.Payload)

	// Field (3) 'BitsB'
	size += len(b.BitsB)

	return
}

// HashTreeRoot ssz hashes the BitlistOffsetStruct object
func (b *BitlistOffsetStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BitlistOffsetStruct object with a hasher
func (b *BitlistOffsetStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(b.Magic)

	// Field (1) 'BitsA'
	if len(b.BitsA) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.BitsA, 1024)

	// Field (2) 'Payload'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(b.Payload))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(b.Payload)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	// Field (3) 'BitsB'
	if len(b.BitsB) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(b.BitsB, 1024)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BitlistOffsetStruct object
func (b *BitlistOffsetStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the GapPairStruct object
func (g *GapPairStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GapPairStruct object to a target array
func (g *GapPairStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := g.fixedSize()

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, g.Magic)

	// Offset (1) 'PayloadA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.PayloadA)

	// Offset (2) 'PayloadB'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'PayloadA'
	if size := uint64(len(g.PayloadA)); size > 1024 {
		err = ssz.ErrBytesLengthFn("GapPairStruct.PayloadA", size, 1024)
		return
	}
	dst = append(dst, g.PayloadA...)

	// Field (2) 'PayloadB'
	if size := uint64(len(g.PayloadB)); size > 1024 {
		err = ssz.ErrBytesLengthFn("GapPairStruct.PayloadB", size, 1024)
		return
	}
	dst = append(dst, g.PayloadB...)

	return
}

// UnmarshalSSZ ssz unmarshals the GapPairStruct object
func (g *GapPairStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(g, buf)
}

// UnmarshalSSZTail unmarshals the GapPairStruct object and returns the remaining bufferº
func (g *GapPairStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := g.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o1, o2 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'Magic'
	g.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Offset (1) 'PayloadA'
	if o1, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (2) 'PayloadB'
	if o2, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'PayloadA'
	if g.PayloadA, err = ssz.UnmarshalDynamicBytes(g.PayloadA, tail[o1:o2], 1024); err != nil {
		return
	}

	// Field (2) 'PayloadB'
	if g.PayloadB, err = ssz.UnmarshalDynamicBytes(g.PayloadB, tail[o2:], 1024); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the GapPairStruct object
func (g *GapPairStruct) fixedSize() int {
	return int(16)
}

// SizeSSZ returns the ssz encoded size in bytes for the GapPairStruct object
func (g *GapPairStruct) SizeSSZ() (size int) {
	size = g.fixedSize()

	// Field (1) 'PayloadA'
	size += len(g.PayloadA)

	// Field (2) 'PayloadB'
	size += len(g.PayloadB)

	return
}

// HashTreeRoot ssz hashes the GapPairStruct object
func (g *GapPairStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GapPairStruct object with a hasher
func (g *GapPairStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(g.Magic)

	// Field (1) 'PayloadA'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadA))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadA)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	// Field (2) 'PayloadB'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadB))
		if byteLen > 1024 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadB)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1024+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GapPairStruct object
func (g *GapPairStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}

// MarshalSSZ ssz marshals the GapWideStruct object
func (g *GapWideStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GapWideStruct object to a target array
func (g *GapWideStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := g.fixedSize()

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, g.Magic)

	// Field (1) 'Padding'
	dst = append(dst, g.Padding[:]...)

	// Offset (2) 'PayloadA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.PayloadA)

	// Offset (3) 'PayloadB'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.PayloadB)

	// Offset (4) 'PayloadC'
	dst = ssz.WriteOffset(dst, offset)

	// Field (2) 'PayloadA'
	if size := uint64(len(g.PayloadA)); size > 512 {
		err = ssz.ErrBytesLengthFn("GapWideStruct.PayloadA", size, 512)
		return
	}
	dst = append(dst, g.PayloadA...)

	// Field (3) 'PayloadB'
	if size := uint64(len(g.PayloadB)); size > 512 {
		err = ssz.ErrBytesLengthFn("GapWideStruct.PayloadB", size, 512)
		return
	}
	dst = append(dst, g.PayloadB...)

	// Field (4) 'PayloadC'
	if size := uint64(len(g.PayloadC)); size > 512 {
		err = ssz.ErrBytesLengthFn("GapWideStruct.PayloadC", size, 512)
		return
	}
	dst = append(dst, g.PayloadC...)

	return
}

// UnmarshalSSZ ssz unmarshals the GapWideStruct object
func (g *GapWideStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(g, buf)
}

// UnmarshalSSZTail unmarshals the GapWideStruct object and returns the remaining bufferº
func (g *GapWideStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := g.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o2, o3, o4 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'Magic'
	g.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Field (1) 'Padding'
	buf = ssz.UnmarshalFixedBytes(g.Padding[:], buf)

	// Offset (2) 'PayloadA'
	if o2, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (3) 'PayloadB'
	if o3, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (4) 'PayloadC'
	if o4, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (2) 'PayloadA'
	if g.PayloadA, err = ssz.UnmarshalDynamicBytes(g.PayloadA, tail[o2:o3], 512); err != nil {
		return
	}

	// Field (3) 'PayloadB'
	if g.PayloadB, err = ssz.UnmarshalDynamicBytes(g.PayloadB, tail[o3:o4], 512); err != nil {
		return
	}

	// Field (4) 'PayloadC'
	if g.PayloadC, err = ssz.UnmarshalDynamicBytes(g.PayloadC, tail[o4:], 512); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the GapWideStruct object
func (g *GapWideStruct) fixedSize() int {
	return int(2068)
}

// SizeSSZ returns the ssz encoded size in bytes for the GapWideStruct object
func (g *GapWideStruct) SizeSSZ() (size int) {
	size = g.fixedSize()

	// Field (2) 'PayloadA'
	size += len(g.PayloadA)

	// Field (3) 'PayloadB'
	size += len(g.PayloadB)

	// Field (4) 'PayloadC'
	size += len(g.PayloadC)

	return
}

// HashTreeRoot ssz hashes the GapWideStruct object
func (g *GapWideStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GapWideStruct object with a hasher
func (g *GapWideStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(g.Magic)

	// Field (1) 'Padding'
	hh.PutBytes(g.Padding[:])

	// Field (2) 'PayloadA'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadA))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadA)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	// Field (3) 'PayloadB'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadB))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadB)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	// Field (4) 'PayloadC'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadC))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadC)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GapWideStruct object
func (g *GapWideStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}

// MarshalSSZ ssz marshals the GapTriStruct object
func (g *GapTriStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GapTriStruct object to a target array
func (g *GapTriStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := g.fixedSize()

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, g.Magic)

	// Offset (1) 'PayloadA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.PayloadA)

	// Offset (2) 'PayloadB'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.PayloadB)

	// Offset (3) 'PayloadC'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'PayloadA'
	if size := uint64(len(g.PayloadA)); size > 512 {
		err = ssz.ErrBytesLengthFn("GapTriStruct.PayloadA", size, 512)
		return
	}
	dst = append(dst, g.PayloadA...)

	// Field (2) 'PayloadB'
	if size := uint64(len(g.PayloadB)); size > 512 {
		err = ssz.ErrBytesLengthFn("GapTriStruct.PayloadB", size, 512)
		return
	}
	dst = append(dst, g.PayloadB...)

	// Field (3) 'PayloadC'
	if size := uint64(len(g.PayloadC)); size > 512 {
		err = ssz.ErrBytesLengthFn("GapTriStruct.PayloadC", size, 512)
		return
	}
	dst = append(dst, g.PayloadC...)

	return
}

// UnmarshalSSZ ssz unmarshals the GapTriStruct object
func (g *GapTriStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(g, buf)
}

// UnmarshalSSZTail unmarshals the GapTriStruct object and returns the remaining bufferº
func (g *GapTriStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := g.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o1, o2, o3 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'Magic'
	g.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Offset (1) 'PayloadA'
	if o1, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (2) 'PayloadB'
	if o2, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (3) 'PayloadC'
	if o3, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'PayloadA'
	if g.PayloadA, err = ssz.UnmarshalDynamicBytes(g.PayloadA, tail[o1:o2], 512); err != nil {
		return
	}

	// Field (2) 'PayloadB'
	if g.PayloadB, err = ssz.UnmarshalDynamicBytes(g.PayloadB, tail[o2:o3], 512); err != nil {
		return
	}

	// Field (3) 'PayloadC'
	if g.PayloadC, err = ssz.UnmarshalDynamicBytes(g.PayloadC, tail[o3:], 512); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the GapTriStruct object
func (g *GapTriStruct) fixedSize() int {
	return int(20)
}

// SizeSSZ returns the ssz encoded size in bytes for the GapTriStruct object
func (g *GapTriStruct) SizeSSZ() (size int) {
	size = g.fixedSize()

	// Field (1) 'PayloadA'
	size += len(g.PayloadA)

	// Field (2) 'PayloadB'
	size += len(g.PayloadB)

	// Field (3) 'PayloadC'
	size += len(g.PayloadC)

	return
}

// HashTreeRoot ssz hashes the GapTriStruct object
func (g *GapTriStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GapTriStruct object with a hasher
func (g *GapTriStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(g.Magic)

	// Field (1) 'PayloadA'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadA))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadA)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	// Field (2) 'PayloadB'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadB))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadB)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	// Field (3) 'PayloadC'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadC))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadC)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GapTriStruct object
func (g *GapTriStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}

// MarshalSSZ ssz marshals the GapScatterStruct object
func (g *GapScatterStruct) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GapScatterStruct object to a target array
func (g *GapScatterStruct) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := g.fixedSize()

	// Field (0) 'Magic'
	dst = ssz.MarshalValue(dst, g.Magic)

	// Offset (1) 'PayloadA'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.PayloadA)

	// Field (2) 'Stamp'
	dst = ssz.MarshalValue(dst, g.Stamp)

	// Offset (3) 'PayloadB'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.PayloadB)

	// Field (4) 'Version'
	dst = ssz.MarshalValue(dst, g.Version)

	// Offset (5) 'PayloadC'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.PayloadC)

	// Offset (6) 'PayloadD'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'PayloadA'
	if size := uint64(len(g.PayloadA)); size > 128 {
		err = ssz.ErrBytesLengthFn("GapScatterStruct.PayloadA", size, 128)
		return
	}
	dst = append(dst, g.PayloadA...)

	// Field (3) 'PayloadB'
	if size := uint64(len(g.PayloadB)); size > 256 {
		err = ssz.ErrBytesLengthFn("GapScatterStruct.PayloadB", size, 256)
		return
	}
	dst = append(dst, g.PayloadB...)

	// Field (5) 'PayloadC'
	if size := uint64(len(g.PayloadC)); size > 512 {
		err = ssz.ErrBytesLengthFn("GapScatterStruct.PayloadC", size, 512)
		return
	}
	dst = append(dst, g.PayloadC...)

	// Field (6) 'PayloadD'
	if size := uint64(len(g.PayloadD)); size > 128 {
		err = ssz.ErrBytesLengthFn("GapScatterStruct.PayloadD", size, 128)
		return
	}
	dst = append(dst, g.PayloadD...)

	return
}

// UnmarshalSSZ ssz unmarshals the GapScatterStruct object
func (g *GapScatterStruct) UnmarshalSSZ(buf []byte) error {
	return ssz.UnmarshalSSZ(g, buf)
}

// UnmarshalSSZTail unmarshals the GapScatterStruct object and returns the remaining bufferº
func (g *GapScatterStruct) UnmarshalSSZTail(buf []byte) (rest []byte, err error) {
	size := len(buf)
	fixedSize := g.fixedSize()
	if size < fixedSize {
		return nil, ssz.ErrSize
	}

	tail := buf
	var o1, o3, o5, o6 uint64
	marker := ssz.NewOffsetMarker(uint64(size), uint64(fixedSize))

	// Field (0) 'Magic'
	g.Magic, buf = ssz.UnmarshallValue[uint64](buf)

	// Offset (1) 'PayloadA'
	if o1, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (2) 'Stamp'
	g.Stamp, buf = ssz.UnmarshallValue[uint32](buf)

	// Offset (3) 'PayloadB'
	if o3, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (4) 'Version'
	g.Version, buf = ssz.UnmarshallValue[uint16](buf)

	// Offset (5) 'PayloadC'
	if o5, buf, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Offset (6) 'PayloadD'
	if o6, _, err = marker.ReadOffset(buf); err != nil {
		return nil, err
	}

	// Field (1) 'PayloadA'
	if g.PayloadA, err = ssz.UnmarshalDynamicBytes(g.PayloadA, tail[o1:o3], 128); err != nil {
		return
	}

	// Field (3) 'PayloadB'
	if g.PayloadB, err = ssz.UnmarshalDynamicBytes(g.PayloadB, tail[o3:o5], 256); err != nil {
		return
	}

	// Field (5) 'PayloadC'
	if g.PayloadC, err = ssz.UnmarshalDynamicBytes(g.PayloadC, tail[o5:o6], 512); err != nil {
		return
	}

	// Field (6) 'PayloadD'
	if g.PayloadD, err = ssz.UnmarshalDynamicBytes(g.PayloadD, tail[o6:], 128); err != nil {
		return
	}

	return
}

// fixedSize returns the fixed size of the GapScatterStruct object
func (g *GapScatterStruct) fixedSize() int {
	return int(30)
}

// SizeSSZ returns the ssz encoded size in bytes for the GapScatterStruct object
func (g *GapScatterStruct) SizeSSZ() (size int) {
	size = g.fixedSize()

	// Field (1) 'PayloadA'
	size += len(g.PayloadA)

	// Field (3) 'PayloadB'
	size += len(g.PayloadB)

	// Field (5) 'PayloadC'
	size += len(g.PayloadC)

	// Field (6) 'PayloadD'
	size += len(g.PayloadD)

	return
}

// HashTreeRoot ssz hashes the GapScatterStruct object
func (g *GapScatterStruct) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GapScatterStruct object with a hasher
func (g *GapScatterStruct) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Magic'
	hh.PutUint64(g.Magic)

	// Field (1) 'PayloadA'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadA))
		if byteLen > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadA)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (128+31)/32)
	}

	// Field (2) 'Stamp'
	hh.PutUint32(g.Stamp)

	// Field (3) 'PayloadB'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadB))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadB)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (4) 'Version'
	hh.PutUint16(g.Version)

	// Field (5) 'PayloadC'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadC))
		if byteLen > 512 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadC)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (512+31)/32)
	}

	// Field (6) 'PayloadD'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(g.PayloadD))
		if byteLen > 128 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(g.PayloadD)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (128+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GapScatterStruct object
func (g *GapScatterStruct) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}
