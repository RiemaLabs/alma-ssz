From 7df50c8568f89f50c583c33ccc5ddea7934cb456 Mon Sep 17 00:00:00 2001
From: kasey <kaseyk@gmail.com>
Date: Wed, 26 May 2021 13:15:20 -0500
Subject: [PATCH] Ensure variable offsets point beyond fixed values (#45)

* Ensure variable offsets point beyond fixed values

In the current generated code, a malformed message where the offset for
a variable length value points beyond the encoded bytes of
fixed-size values will unmarshal without complaint, resulting in a
corrupt runtime value.

* fix off-by-one; regenerate spec tests

* bound check all offsets closer to decoding

* update spec tests with change to unmarshal

* remove redundant checks for offsets after 1st
---
 encode.go                     |  1 +
 spectests/structs_encoding.go | 40 +++++++++++++++++++++++++++++++++++
 spectests/structs_test.go     | 17 +++++++++------
 sszgen/unmarshal.go           | 15 +++++++++++--
 4 files changed, 65 insertions(+), 8 deletions(-)

diff --git a/encode.go b/encode.go
index d7d2d8a..205b039 100644
--- a/encode.go
+++ b/encode.go
@@ -21,6 +21,7 @@ var (
 	ErrVectorLength = fmt.Errorf("vector does not have the correct length")
 	ErrListTooBig   = fmt.Errorf("list length is higher than max value")
 	ErrEmptyBitlist = fmt.Errorf("bitlist is empty")
+	ErrInvalidVariableOffset = fmt.Errorf("invalid ssz encoding. first variable element offset indexes into fixed value data")
 )
 
 // ---- Unmarshal functions ----
diff --git a/spectests/structs_encoding.go b/spectests/structs_encoding.go
index 3dd2338..61b83d9 100644
--- a/spectests/structs_encoding.go
+++ b/spectests/structs_encoding.go
@@ -60,6 +60,10 @@ func (a *AggregateAndProof) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o1 < 108 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Field (2) 'SelectionProof'
 	if err = a.SelectionProof.UnmarshalSSZ(buf[12:108]); err != nil {
 		return err
@@ -355,6 +359,10 @@ func (a *Attestation) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o0 < 228 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Field (1) 'Data'
 	if a.Data == nil {
 		a.Data = new(AttestationData)
@@ -764,6 +772,10 @@ func (i *IndexedAttestation) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o0 < 228 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Field (1) 'Data'
 	if i.Data == nil {
 		i.Data = new(AttestationData)
@@ -897,6 +909,10 @@ func (p *PendingAttestation) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o0 < 148 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Field (1) 'Data'
 	if p.Data == nil {
 		p.Data = new(AttestationData)
@@ -1796,6 +1812,10 @@ func (a *AttesterSlashing) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o0 < 8 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Offset (1) 'Attestation2'
 	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
 		return ssz.ErrOffset
@@ -2136,6 +2156,10 @@ func (b *BeaconState) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o6 < 7017 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Field (7) 'Eth1Data'
 	if b.Eth1Data == nil {
 		b.Eth1Data = new(Eth1Data)
@@ -2633,6 +2657,10 @@ func (b *BeaconBlock) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o3 < 76 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Field (3) 'Body'
 	{
 		buf = tail[o3:]
@@ -2742,6 +2770,10 @@ func (s *SignedBeaconBlock) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o0 < 100 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Field (1) 'Signature'
 	if cap(s.Signature) == 0 {
 		s.Signature = make([]byte, 0, len(buf[4:100]))
@@ -3085,6 +3117,10 @@ func (b *BeaconBlockBody) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o3 < 220 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Offset (4) 'AttesterSlashings'
 	if o4 = ssz.ReadOffset(buf[204:208]); o4 > size || o3 > o4 {
 		return ssz.ErrOffset
@@ -3573,6 +3609,10 @@ func (e *ErrorResponse) UnmarshalSSZ(buf []byte) error {
 		return ssz.ErrOffset
 	}
 
+	if o0 < 4 {
+		return ssz.ErrInvalidVariableOffset
+	}
+
 	// Field (0) 'Message'
 	{
 		buf = tail[o0:]
diff --git a/spectests/structs_test.go b/spectests/structs_test.go
index 2b235e0..232426d 100644
--- a/spectests/structs_test.go
+++ b/spectests/structs_test.go
@@ -267,7 +267,7 @@ func TestSpecMinimal(t *testing.T) {
 
 		t.Log(f)
 		for _, f := range walkPath(t, f) {
-			checkSSZEncoding(t, f, base)
+			checkSSZEncoding(t, f, name, base)
 		}
 	}
 }
@@ -289,14 +289,19 @@ func TestSpecMainnet(t *testing.T) {
 		t.Log(f)
 		files := readDir(t, filepath.Join(f, "ssz_random"))
 		for _, f := range files {
-			checkSSZEncoding(t, f, base)
+			checkSSZEncoding(t, f, name, base)
 		}
 	}
 }
 
-func checkSSZEncoding(t *testing.T, f string, base testCallback) {
+func formatSpecFailure(errHeader, specFile, structName string, err error) string {
+	return fmt.Sprintf("%s spec file=%s, struct=%s, err=%v",
+		errHeader, specFile, structName, err)
+}
+
+func checkSSZEncoding(t *testing.T, fileName, structName string, base testCallback) {
 	obj := base()
-	output := readValidGenericSSZ(t, f, &obj)
+	output := readValidGenericSSZ(t, fileName, &obj)
 
 	// Marshal
 	res, err := obj.MarshalSSZTo(nil)
@@ -310,7 +315,7 @@ func checkSSZEncoding(t *testing.T, f string, base testCallback) {
 	// Unmarshal
 	obj2 := base()
 	if err := obj2.UnmarshalSSZ(res); err != nil {
-		panic(err)
+		t.Fatal(formatSpecFailure("UnmarshalSSZ error", fileName, structName, err))
 	}
 	if !deepEqual(obj, obj2) {
 		t.Fatal("bad unmarshalling")
@@ -322,7 +327,7 @@ func checkSSZEncoding(t *testing.T, f string, base testCallback) {
 		t.Fatal(err)
 	}
 	if !bytes.Equal(root[:], output.root) {
-		fmt.Printf("%s bad root\n", f)
+		fmt.Printf("%s bad root\n", fileName)
 	}
 
 	if objt, ok := obj.(codecTree); ok {
diff --git a/sszgen/unmarshal.go b/sszgen/unmarshal.go
index 836fd3c..ec1724f 100644
--- a/sszgen/unmarshal.go
+++ b/sszgen/unmarshal.go
@@ -225,6 +225,11 @@ func (v *Value) umarshalContainer(start bool, dst string) (str string) {
 
 	// Marshal the fixed part and offsets
 
+	// used for bounds checking of variable length offsets.
+	// for the first offset, use the size of the fixed-length data
+	// as the minimum boundary. subsequent offsets will replace this
+	// value with the name of the previous offset variable.
+	firstOffsetCheck := fmt.Sprintf("%d", v.n)
 	outs := []string{}
 	for indx, i := range v.o {
 
@@ -252,6 +257,7 @@ func (v *Value) umarshalContainer(start bool, dst string) (str string) {
 				"name":   i.name,
 				"offset": offset,
 				"dst":    dst,
+				"firstOffsetCheck": firstOffsetCheck,
 			}
 
 			// We need to do two validations for the offset:
@@ -268,8 +274,14 @@ func (v *Value) umarshalContainer(start bool, dst string) (str string) {
 			if {{.offset}} = ssz.ReadOffset({{.dst}}); {{.offset}} > size {{.more}} {
 				return ssz.ErrOffset
 			}
+			{{ if .firstOffsetCheck }}
+			if {{.offset}} < {{.firstOffsetCheck}} {
+				return ssz.ErrInvalidVariableOffset
+			}
+			{{ end }}
 			`
 			res = execTmpl(tmpl, data)
+			firstOffsetCheck = ""
 		}
 		outs = append(outs, res)
 	}
@@ -277,9 +289,9 @@ func (v *Value) umarshalContainer(start bool, dst string) (str string) {
 	// Marshal the dynamic parts
 
 	c := 0
+
 	for indx, i := range v.o {
 		if !i.isFixed() {
-
 			from := offsets[c]
 			var to string
 			if c == len(offsets)-1 {
@@ -287,7 +299,6 @@ func (v *Value) umarshalContainer(start bool, dst string) (str string) {
 			} else {
 				to = offsets[c+1]
 			}
-
 			tmpl := `// Field ({{.indx}}) '{{.name}}'
 			{
 				buf = tail[{{.from}}:{{.to}}]
-- 
2.50.1

