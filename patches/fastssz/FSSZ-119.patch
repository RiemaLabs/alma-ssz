diff --git a/tree.go b/tree.go
index e02a9fa..25e76d9 100644
--- a/tree.go
+++ b/tree.go
@@ -193,78 +193,33 @@ func TreeFromChunks(chunks [][]byte) (*Node, error) {
 // Adjacent sibling nodes will be filled with zero order hashes that have been precomputed based on the tree depth.
 func TreeFromNodes(leaves []*Node, limit int) (*Node, error) {
 	numLeaves := len(leaves)
-
-	depth := floorLog2(limit)
-	zeroOrderHashes := getZeroOrderHashes(depth)
-
-	// there are no leaves, return a zero order hash node
-	if numLeaves == 0 {
-		return NewEmptyNode(zeroOrderHashes[0]), nil
-	}
-
-	// now we know numLeaves are at least 1.
-
-	// if the max leaf limit is 1, return the one leaf we have
-	if limit == 1 {
-		return leaves[0], nil
-	}
-	// if the max leaf limit is 2
-	if limit == 2 {
-		// but we only have 1 leaf, add a zero order hash as the right node
-		if numLeaves == 1 {
-			return NewNodeWithLR(leaves[0], NewEmptyNode(zeroOrderHashes[1])), nil
-		}
-		// otherwise return the two nodes we have
-		return NewNodeWithLR(leaves[0], leaves[1]), nil
-	}
-
 	if !isPowerOfTwo(limit) {
 		return nil, errors.New("number of leaves should be a power of 2")
 	}
 
-	leavesStart := powerTwo(depth)
-	leafIndex := numLeaves - 1
-
-	nodes := make(map[int]*Node)
-
-	nodesStartIndex := leavesStart
-	nodesEndIndex := nodesStartIndex + numLeaves - 1
-
-	// for each tree level
-	for k := depth; k >= 0; k-- {
-		for i := nodesEndIndex; i >= nodesStartIndex; i-- {
-			// leaf node, add to map
-			if k == depth {
-				nodes[i] = leaves[leafIndex]
-				leafIndex--
-			} else { // branch node, compute
-				leftIndex := i * 2
-				rightIndex := i*2 + 1
-				// both nodes are empty, unexpected condition
-				if nodes[leftIndex] == nil && nodes[rightIndex] == nil {
-					return nil, errors.New("unexpected empty right and left nodes")
-				}
-				// node with empty right node, add zero order hash as right node and mark right node as empty
-				if nodes[leftIndex] != nil && nodes[rightIndex] == nil {
-					nodes[i] = NewNodeWithLR(nodes[leftIndex], NewEmptyNode(zeroOrderHashes[k+1]))
-				}
-				// node with left and right child
-				if nodes[leftIndex] != nil && nodes[rightIndex] != nil {
-					nodes[i] = NewNodeWithLR(nodes[leftIndex], nodes[rightIndex])
-				}
-			}
+	allLeaves := make([]*Node, limit)
+	emptyLeaf := NewNodeWithValue(make([]byte, 32))
+	for i := 0; i < limit; i++ {
+		if i < numLeaves {
+			allLeaves[i] = leaves[i]
+		} else {
+			allLeaves[i] = emptyLeaf
 		}
-		nodesStartIndex = nodesStartIndex / 2
-		nodesEndIndex = int(math.Floor(float64(nodesEndIndex)) / 2)
 	}
 
-	rootNode := nodes[1]
-
-	if rootNode == nil {
-		return nil, errors.New("tree root node could not be computed")
+	numNodes := limit*2 - 1
+	nodes := make([]*Node, numNodes)
+	for i := numNodes; i > 0; i-- {
+		// Is a leaf
+		if i > numNodes-limit {
+			nodes[i-1] = allLeaves[i-limit]
+		} else {
+			// Is a branch node
+			nodes[i-1] = NewNodeWithLR(nodes[(i*2)-1], nodes[(i*2+1)-1])
+		}
 	}
 
-	return nodes[1], nil
+	return nodes[0], nil
 }
 
 func TreeFromNodesWithMixin(leaves []*Node, num, limit int) (*Node, error) {
