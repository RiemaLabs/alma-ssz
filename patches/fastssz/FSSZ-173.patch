diff --git a/proof.go b/proof.go
index 6a11f54..e9e6146 100644
--- a/proof.go
+++ b/proof.go
@@ -54,10 +54,6 @@ func VerifyProof(root []byte, proof *Proof) (bool, error) {
 // Let's call such hashes "*5", "*6" and "*15" respectively.
 // Then, when calling this function `proof` should be ordered as [*15, *6, *5].
 func VerifyMultiproof(root []byte, proof [][]byte, leaves [][]byte, indices []int) (bool, error) {
-	if len(indices) == 0 {
-		return false, errors.New("indices length is zero")
-	}
-
 	if len(leaves) != len(indices) {
 		return false, errors.New("number of leaves and indices mismatch")
 	}
@@ -67,85 +63,50 @@ func VerifyMultiproof(root []byte, proof [][]byte, leaves [][]byte, indices []in
 		return false, fmt.Errorf("number of proof hashes %d and required indices %d mismatch", len(proof), len(reqIndices))
 	}
 
-	// userGenIndices contains all generalised indices between leaves and proof hashes
-	// i.e., the indices retrieved from the user of this function
-	userGenIndices := make([]int, len(indices)+len(reqIndices))
-	pos := 0
-	// Create database of index -> value (hash) from inputs
+	keys := make([]int, len(indices)+len(reqIndices))
+	nk := 0
+	// Create database of index -> value (hash)
+	// from inputs
 	db := make(map[int][]byte)
 	for i, leaf := range leaves {
 		db[indices[i]] = leaf
-		userGenIndices[pos] = indices[i]
-		pos++
+		keys[nk] = indices[i]
+		nk++
 	}
 	for i, h := range proof {
 		db[reqIndices[i]] = h
-		userGenIndices[pos] = reqIndices[i]
-		pos++
+		keys[nk] = reqIndices[i]
+		nk++
 	}
+	sort.Sort(sort.Reverse(sort.IntSlice(keys)))
 
-	// Make sure keys are sorted in reverse order since we start from the leaves
-	sort.Sort(sort.Reverse(sort.IntSlice(userGenIndices)))
-
-	// The depth of the tree up to the greatest index
-	cap := int(math.Log2(float64(userGenIndices[0])))
-
-	// Allocate space for auxiliary keys created when computing intermediate hashes
-	// Auxiliary indices are useful to avoid using store all indices to traverse
-	// in a single array and sort upon an insertion, which would be inefficient.
-	auxGenIndices := make([]int, 0, cap)
-
-	// To keep track the current position to inspect in both arrays
-	pos = 0
-	posAux := 0
-
+	pos := 0
 	tmp := make([]byte, 64)
-	var index int
-
-	// Iter over the tree, computing hashes and storing them
-	// in the in-memory database, until the root is reached.
-	//
-	// EXIT CONDITION: no more indices to use in both arrays
-	for posAux < len(auxGenIndices) || pos < len(userGenIndices) {
-		// We need to establish from which array we're going to take the next index
-		//
-		// 1. If we've no auxiliary indices yet, we're going to use the generalised ones
-		// 2. If we have no more client indices, we're going to use the auxiliary ones
-		// 3. If we both, then we're going to compare them and take the biggest one
-		if len(auxGenIndices) == 0 || (pos < len(userGenIndices) && auxGenIndices[posAux] < userGenIndices[pos]) {
-			index = userGenIndices[pos]
-			pos++
-		} else {
-			index = auxGenIndices[posAux]
-			posAux++
-		}
-
+	for pos < len(keys) {
+		k := keys[pos]
 		// Root has been reached
-		if index == 1 {
+		if k == 1 {
 			break
 		}
 
-		// If the parent is already computed, we don't need to calculate the intermediate hash
-		_, hasParent := db[getParent(index)]
+		_, hasParent := db[getParent(k)]
 		if hasParent {
+			pos++
 			continue
 		}
 
-		left, hasLeft := db[(index|1)^1]
-		right, hasRight := db[index|1]
+		left, hasLeft := db[(k|1)^1]
+		right, hasRight := db[k|1]
 		if !hasRight || !hasLeft {
-			return false, fmt.Errorf("proof is missing required nodes, either %d or %d", (index|1)^1, index|1)
+			return false, fmt.Errorf("proof is missing required nodes, either %d or %d", (k|1)^1, k|1)
 		}
 
 		copy(tmp[:32], left[:])
 		copy(tmp[32:], right[:])
-		parentIndex := getParent(index)
-		db[parentIndex] = hashFn(tmp)
-
-		// An intermediate hash has been computed, as such we need to store its index
-		// to remember to examine it later
-		auxGenIndices = append(auxGenIndices, parentIndex)
+		db[getParent(k)] = hashFn(tmp)
+		keys = append(keys, getParent(k))
 
+		pos++
 	}
 
 	res, ok := db[1]
